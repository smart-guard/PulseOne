// collector/include/Common/BasicTypes.h
#ifndef PULSEONE_COMMON_BASIC_TYPES_H
#define PULSEONE_COMMON_BASIC_TYPES_H

/**
 * @file BasicTypes.h
 * @brief PulseOne 기본 타입 정의 (최우선 기반 클래스)
 * @author PulseOne Development Team
 * @date 2025-08-04
 * @details 
 * 🎯 목적: 기존 프로젝트와 100% 호환되면서 새로운 통합 아키텍처의 기반
 * 📋 기존 코드 분석 결과:
 * - ConfigManager, LogManager, DatabaseManager 등이 이미 존재
 * - Utils/LogLevels.h, Common/Structs.h 등 기존 구조 유지
 * - 새로운 타입들은 기존과 충돌하지 않도록 설계
 */

#include <string>
#include <variant>
#include <chrono>
#include <cstdint>
#include <vector>
#include <memory>

// 조건부 UniqueId 라이브러리 include
#ifdef _WIN32
    #include <rpc.h>
    #pragma comment(lib, "rpcrt4.lib")
#elif defined(__APPLE__)
    #include <UniqueId/UniqueId.h>
#elif defined(__linux__)
    #include <UniqueId/UniqueId.h>
#else
    // Fallback: 간단한 UniqueId 구현
#endif

namespace PulseOne {
namespace BasicTypes {

    // =========================================================================
    // 🔥 핵심 기본 타입들 (기존 프로젝트와 호환)
    // =========================================================================
    
    /**
     * @brief UniqueId 타입 (범용 고유 식별자)
     * @details 디바이스, 데이터 포인트, 요청 등의 식별에 사용
     */
    using UniqueId = std::string;  // 기존 프로젝트가 string 기반이므로 호환성 유지
    
    /**
     * @brief 타임스탬프 타입
     * @details 모든 시간 관련 데이터에 사용
     */
    using Timestamp = std::chrono::system_clock::time_point;
    
    /**
     * @brief 시간 간격 타입
     * @details 타임아웃, 주기 등에 사용
     */
    using Duration = std::chrono::milliseconds;
    
    /**
     * @brief 엔지니어 ID 타입 (점검 기능용)
     * @details 점검 모드 진입 시 엔지니어 식별
     */
    using EngineerID = std::string;

    // =========================================================================  
    // 🔥 데이터 값 변형 타입 (모든 프로토콜 지원)
    // =========================================================================
    
    /**
     * @brief 범용 데이터 값 타입
     * @details 모든 프로토콜에서 사용하는 통합 데이터 타입
     * - Modbus: 레지스터 값들
     * - MQTT: JSON 페이로드 값들  
     * - BACnet: Property 값들
     */
    using DataVariant = std::variant<
        bool,           // 0: 불린 값 (코일, 디지털 입력)
        int16_t,        // 1: 16비트 정수 (Modbus 레지스터)
        uint16_t,       // 2: 16비트 부호없는 정수
        int32_t,        // 3: 32비트 정수 (확장)
        uint32_t,       // 4: 32비트 부호없는 정수
        float,          // 5: 32비트 부동소수점 (아날로그 값)
        double,         // 6: 64비트 부동소수점 (고정밀)
        std::string     // 7: 문자열 (MQTT JSON, BACnet 문자열)
    >;
    
    // =========================================================================
    // 🔥 유틸리티 함수들 (기존 Utils와 중복 방지)
    // =========================================================================
    
    /**
     * @brief UniqueId 생성 함수
     * @return 새로운 UniqueId 문자열
     * @details 플랫폼별 최적화된 UniqueId 생성
     */
    inline UniqueId GenerateUniqueId() {
        #ifdef _WIN32
            UniqueId UniqueId;
            RPC_CSTR UniqueId_string;
            if (UniqueIdCreate(&UniqueId) == RPC_S_OK) {
                if (UniqueIdToStringA(&UniqueId, &UniqueId_string) == RPC_S_OK) {
                    std::string result(reinterpret_cast<char*>(UniqueId_string));
                    RpcStringFreeA(&UniqueId_string);
                    return result;
                }
            }
            // Fallback
            return "UniqueId-" + std::to_string(std::chrono::steady_clock::now().time_since_epoch().count());
            
        #elif defined(__APPLE__) || defined(__linux__)
            UniqueId_t UniqueId;
            UniqueId_generate_random(UniqueId);
            char UniqueId_str[37];
            UniqueId_unparse_lower(UniqueId, UniqueId_str);
            return std::string(UniqueId_str);
            
        #else
            // Simple fallback UniqueId
            static uint64_t counter = 0;
            auto now = std::chrono::high_resolution_clock::now();
            auto timestamp = now.time_since_epoch().count();
            return "UniqueId-" + std::to_string(timestamp) + "-" + std::to_string(++counter);
        #endif
    }
    
    /**
     * @brief 현재 타임스탬프 반환
     * @return 현재 시간 타임스탬프
     */
    inline Timestamp CurrentTimestamp() {
        return std::chrono::system_clock::now();
    }
    
    /**
     * @brief 타임스탬프를 문자열로 변환
     * @param timestamp 변환할 타임스탬프
     * @param format 포맷 문자열 (기본: ISO 8601)
     * @return 포맷된 시간 문자열
     */
    inline std::string TimestampToString(const Timestamp& timestamp, 
                                        const std::string& format = "%Y-%m-%dT%H:%M:%S") {
        auto time_t = std::chrono::system_clock::to_time_t(timestamp);
        std::tm tm_buf;
        
        #ifdef _WIN32
            localtime_s(&tm_buf, &time_t);
        #else
            localtime_r(&time_t, &tm_buf);
        #endif
        
        char buffer[128];
        std::strftime(buffer, sizeof(buffer), format.c_str(), &tm_buf);
        
        // 밀리초 추가
        auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
            timestamp.time_since_epoch()) % 1000;
        
        return std::string(buffer) + "." + 
               std::to_string(ms.count()).insert(0, 3 - std::to_string(ms.count()).length(), '0');
    }
    
    /**
     * @brief DataVariant의 타입 인덱스 반환
     * @param value 값
     * @return 타입 인덱스 (0=bool, 1=int16_t, ..., 7=string)
     */
    inline size_t GetDataVariantTypeIndex(const DataVariant& value) {
        return value.index();
    }
    
    /**
     * @brief DataVariant를 문자열로 변환
     * @param value 변환할 값
     * @return 문자열 표현
     */
    inline std::string DataVariantToString(const DataVariant& value) {
        return std::visit([](const auto& v) -> std::string {
            using T = std::decay_t<decltype(v)>;
            if constexpr (std::is_same_v<T, std::string>) {
                return v;
            } else if constexpr (std::is_same_v<T, bool>) {
                return v ? "true" : "false";
            } else {
                return std::to_string(v);
            }
        }, value);
    }
    
    /**
     * @brief 문자열을 DataVariant로 변환 (타입 추론)
     * @param str 변환할 문자열
     * @param hint_type 타입 힌트 (기본값: 자동 추론)
     * @return 변환된 DataVariant
     */
    inline DataVariant StringToDataVariant(const std::string& str, size_t hint_type = 7) {
        // 자동 타입 추론
        if (hint_type == 7) {  // 자동 추론 모드
            // 불린 체크
            if (str == "true" || str == "TRUE" || str == "1") return true;
            if (str == "false" || str == "FALSE" || str == "0") return false;
            
            // 숫자 체크
            try {
                // 소수점 포함 여부 확인
                if (str.find('.') != std::string::npos) {
                    double d = std::stod(str);
                    float f = static_cast<float>(d);
                    // 정밀도 손실이 없으면 float 사용
                    if (std::abs(d - static_cast<double>(f)) < 1e-6) {
                        return f;
                    } else {
                        return d;
                    }
                } else {
                    // 정수 처리
                    long long ll = std::stoll(str);
                    if (ll >= INT16_MIN && ll <= INT16_MAX) {
                        return static_cast<int16_t>(ll);
                    } else if (ll >= 0 && ll <= UINT16_MAX) {
                        return static_cast<uint16_t>(ll);
                    } else if (ll >= INT32_MIN && ll <= INT32_MAX) {
                        return static_cast<int32_t>(ll);
                    } else if (ll >= 0 && ll <= UINT32_MAX) {
                        return static_cast<uint32_t>(ll);
                    }
                }
            } catch (...) {
                // 숫자 변환 실패 시 문자열로 처리
            }
        }
        
        // 힌트 기반 변환 또는 기본 문자열 반환
        switch (hint_type) {
            case 0: return str == "true" || str == "1";
            case 1: try { return static_cast<int16_t>(std::stoi(str)); } catch (...) { break; }
            case 2: try { return static_cast<uint16_t>(std::stoul(str)); } catch (...) { break; }
            case 3: try { return static_cast<int32_t>(std::stol(str)); } catch (...) { break; }
            case 4: try { return static_cast<uint32_t>(std::stoul(str)); } catch (...) { break; }
            case 5: try { return std::stof(str); } catch (...) { break; }
            case 6: try { return std::stod(str); } catch (...) { break; }
            default: break;
        }
        
        return str;  // 기본값: 문자열
    }

    // =========================================================================
    // 🔥 메모리 및 성능 최적화 타입들
    // =========================================================================
    
    /**
     * @brief 경량 문자열 뷰 (C++17 호환)
     * @details 문자열 복사 없이 참조만 제공 (성능 최적화)
     */
    using StringView = std::string_view;
    
    /**
     * @brief 스마트 포인터 별칭들
     */
    template<typename T>
    using UniquePtr = std::unique_ptr<T>;
    
    template<typename T>
    using SharedPtr = std::shared_ptr<T>;
    
    template<typename T>
    using WeakPtr = std::weak_ptr<T>;
    
    /**
     * @brief 벡터 별칭들 (자주 사용되는 타입들)
     */
    using StringVector = std::vector<std::string>;
    using UniqueIdVector = std::vector<UniqueId>;
    using DataVariantVector = std::vector<DataVariant>;

    // =========================================================================
    // 🔥 기존 PulseOne 프로젝트와의 호환성 보장
    // =========================================================================
    
    /**
     * @brief 기존 프로젝트 호환성을 위한 타입 별칭들
     * @details 기존 코드가 계속 작동하도록 보장
     */
    namespace Compatibility {
        // 기존 코드에서 사용했을 수 있는 타입들
        using DeviceId = UniqueId;
        using PointId = UniqueId;
        using RequestId = UniqueId;
        using Value = DataVariant;
        using TimeStamp = Timestamp;  // 기존 스타일
    }

} // namespace BasicTypes
} // namespace PulseOne

#endif // PULSEONE_COMMON_BASIC_TYPES_H