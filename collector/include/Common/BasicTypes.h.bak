// collector/include/Common/BasicTypes.h
#ifndef PULSEONE_COMMON_BASIC_TYPES_H
#define PULSEONE_COMMON_BASIC_TYPES_H

/**
 * @file BasicTypes.h
 * @brief PulseOne ê¸°ë³¸ íƒ€ì… ì •ì˜ (ìµœìš°ì„  ê¸°ë°˜ í´ë˜ìŠ¤)
 * @author PulseOne Development Team
 * @date 2025-08-04
 * @details 
 * ğŸ¯ ëª©ì : ê¸°ì¡´ í”„ë¡œì íŠ¸ì™€ 100% í˜¸í™˜ë˜ë©´ì„œ ìƒˆë¡œìš´ í†µí•© ì•„í‚¤í…ì²˜ì˜ ê¸°ë°˜
 * ğŸ“‹ ê¸°ì¡´ ì½”ë“œ ë¶„ì„ ê²°ê³¼:
 * - ConfigManager, LogManager, DatabaseManager ë“±ì´ ì´ë¯¸ ì¡´ì¬
 * - Utils/LogLevels.h, Common/Structs.h ë“± ê¸°ì¡´ êµ¬ì¡° ìœ ì§€
 * - ìƒˆë¡œìš´ íƒ€ì…ë“¤ì€ ê¸°ì¡´ê³¼ ì¶©ëŒí•˜ì§€ ì•Šë„ë¡ ì„¤ê³„
 */

#include <string>
#include <variant>
#include <chrono>
#include <cstdint>
#include <vector>
#include <memory>

// ì¡°ê±´ë¶€ UniqueId ë¼ì´ë¸ŒëŸ¬ë¦¬ include
#ifdef _WIN32
    #include <rpc.h>
    #pragma comment(lib, "rpcrt4.lib")
#elif defined(__APPLE__)
    #include <UniqueId/UniqueId.h>
#elif defined(__linux__)
    #include <UniqueId/UniqueId.h>
#else
    // Fallback: ê°„ë‹¨í•œ UniqueId êµ¬í˜„
#endif

namespace PulseOne {
namespace BasicTypes {

    // =========================================================================
    // ğŸ”¥ í•µì‹¬ ê¸°ë³¸ íƒ€ì…ë“¤ (ê¸°ì¡´ í”„ë¡œì íŠ¸ì™€ í˜¸í™˜)
    // =========================================================================
    
    /**
     * @brief UniqueId íƒ€ì… (ë²”ìš© ê³ ìœ  ì‹ë³„ì)
     * @details ë””ë°”ì´ìŠ¤, ë°ì´í„° í¬ì¸íŠ¸, ìš”ì²­ ë“±ì˜ ì‹ë³„ì— ì‚¬ìš©
     */
    using UniqueId = std::string;  // ê¸°ì¡´ í”„ë¡œì íŠ¸ê°€ string ê¸°ë°˜ì´ë¯€ë¡œ í˜¸í™˜ì„± ìœ ì§€
    
    /**
     * @brief íƒ€ì„ìŠ¤íƒ¬í”„ íƒ€ì…
     * @details ëª¨ë“  ì‹œê°„ ê´€ë ¨ ë°ì´í„°ì— ì‚¬ìš©
     */
    using Timestamp = std::chrono::system_clock::time_point;
    
    /**
     * @brief ì‹œê°„ ê°„ê²© íƒ€ì…
     * @details íƒ€ì„ì•„ì›ƒ, ì£¼ê¸° ë“±ì— ì‚¬ìš©
     */
    using Duration = std::chrono::milliseconds;
    
    /**
     * @brief ì—”ì§€ë‹ˆì–´ ID íƒ€ì… (ì ê²€ ê¸°ëŠ¥ìš©)
     * @details ì ê²€ ëª¨ë“œ ì§„ì… ì‹œ ì—”ì§€ë‹ˆì–´ ì‹ë³„
     */
    using EngineerID = std::string;

    // =========================================================================  
    // ğŸ”¥ ë°ì´í„° ê°’ ë³€í˜• íƒ€ì… (ëª¨ë“  í”„ë¡œí† ì½œ ì§€ì›)
    // =========================================================================
    
    /**
     * @brief ë²”ìš© ë°ì´í„° ê°’ íƒ€ì…
     * @details ëª¨ë“  í”„ë¡œí† ì½œì—ì„œ ì‚¬ìš©í•˜ëŠ” í†µí•© ë°ì´í„° íƒ€ì…
     * - Modbus: ë ˆì§€ìŠ¤í„° ê°’ë“¤
     * - MQTT: JSON í˜ì´ë¡œë“œ ê°’ë“¤  
     * - BACnet: Property ê°’ë“¤
     */
    using DataVariant = std::variant<
        bool,           // 0: ë¶ˆë¦° ê°’ (ì½”ì¼, ë””ì§€í„¸ ì…ë ¥)
        int16_t,        // 1: 16ë¹„íŠ¸ ì •ìˆ˜ (Modbus ë ˆì§€ìŠ¤í„°)
        uint16_t,       // 2: 16ë¹„íŠ¸ ë¶€í˜¸ì—†ëŠ” ì •ìˆ˜
        int32_t,        // 3: 32ë¹„íŠ¸ ì •ìˆ˜ (í™•ì¥)
        uint32_t,       // 4: 32ë¹„íŠ¸ ë¶€í˜¸ì—†ëŠ” ì •ìˆ˜
        float,          // 5: 32ë¹„íŠ¸ ë¶€ë™ì†Œìˆ˜ì  (ì•„ë‚ ë¡œê·¸ ê°’)
        double,         // 6: 64ë¹„íŠ¸ ë¶€ë™ì†Œìˆ˜ì  (ê³ ì •ë°€)
        std::string     // 7: ë¬¸ìì—´ (MQTT JSON, BACnet ë¬¸ìì—´)
    >;
    
    // =========================================================================
    // ğŸ”¥ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤ (ê¸°ì¡´ Utilsì™€ ì¤‘ë³µ ë°©ì§€)
    // =========================================================================
    
    /**
     * @brief UniqueId ìƒì„± í•¨ìˆ˜
     * @return ìƒˆë¡œìš´ UniqueId ë¬¸ìì—´
     * @details í”Œë«í¼ë³„ ìµœì í™”ëœ UniqueId ìƒì„±
     */
    inline UniqueId GenerateUniqueId() {
        #ifdef _WIN32
            UniqueId UniqueId;
            RPC_CSTR UniqueId_string;
            if (UniqueIdCreate(&UniqueId) == RPC_S_OK) {
                if (UniqueIdToStringA(&UniqueId, &UniqueId_string) == RPC_S_OK) {
                    std::string result(reinterpret_cast<char*>(UniqueId_string));
                    RpcStringFreeA(&UniqueId_string);
                    return result;
                }
            }
            // Fallback
            return "UniqueId-" + std::to_string(std::chrono::steady_clock::now().time_since_epoch().count());
            
        #elif defined(__APPLE__) || defined(__linux__)
            UniqueId_t UniqueId;
            UniqueId_generate_random(UniqueId);
            char UniqueId_str[37];
            UniqueId_unparse_lower(UniqueId, UniqueId_str);
            return std::string(UniqueId_str);
            
        #else
            // Simple fallback UniqueId
            static uint64_t counter = 0;
            auto now = std::chrono::high_resolution_clock::now();
            auto timestamp = now.time_since_epoch().count();
            return "UniqueId-" + std::to_string(timestamp) + "-" + std::to_string(++counter);
        #endif
    }
    
    /**
     * @brief í˜„ì¬ íƒ€ì„ìŠ¤íƒ¬í”„ ë°˜í™˜
     * @return í˜„ì¬ ì‹œê°„ íƒ€ì„ìŠ¤íƒ¬í”„
     */
    inline Timestamp CurrentTimestamp() {
        return std::chrono::system_clock::now();
    }
    
    /**
     * @brief íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
     * @param timestamp ë³€í™˜í•  íƒ€ì„ìŠ¤íƒ¬í”„
     * @param format í¬ë§· ë¬¸ìì—´ (ê¸°ë³¸: ISO 8601)
     * @return í¬ë§·ëœ ì‹œê°„ ë¬¸ìì—´
     */
    inline std::string TimestampToString(const Timestamp& timestamp, 
                                        const std::string& format = "%Y-%m-%dT%H:%M:%S") {
        auto time_t = std::chrono::system_clock::to_time_t(timestamp);
        std::tm tm_buf;
        
        #ifdef _WIN32
            localtime_s(&tm_buf, &time_t);
        #else
            localtime_r(&time_t, &tm_buf);
        #endif
        
        char buffer[128];
        std::strftime(buffer, sizeof(buffer), format.c_str(), &tm_buf);
        
        // ë°€ë¦¬ì´ˆ ì¶”ê°€
        auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
            timestamp.time_since_epoch()) % 1000;
        
        return std::string(buffer) + "." + 
               std::to_string(ms.count()).insert(0, 3 - std::to_string(ms.count()).length(), '0');
    }
    
    /**
     * @brief DataVariantì˜ íƒ€ì… ì¸ë±ìŠ¤ ë°˜í™˜
     * @param value ê°’
     * @return íƒ€ì… ì¸ë±ìŠ¤ (0=bool, 1=int16_t, ..., 7=string)
     */
    inline size_t GetDataVariantTypeIndex(const DataVariant& value) {
        return value.index();
    }
    
    /**
     * @brief DataVariantë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
     * @param value ë³€í™˜í•  ê°’
     * @return ë¬¸ìì—´ í‘œí˜„
     */
    inline std::string DataVariantToString(const DataVariant& value) {
        return std::visit([](const auto& v) -> std::string {
            using T = std::decay_t<decltype(v)>;
            if constexpr (std::is_same_v<T, std::string>) {
                return v;
            } else if constexpr (std::is_same_v<T, bool>) {
                return v ? "true" : "false";
            } else {
                return std::to_string(v);
            }
        }, value);
    }
    
    /**
     * @brief ë¬¸ìì—´ì„ DataVariantë¡œ ë³€í™˜ (íƒ€ì… ì¶”ë¡ )
     * @param str ë³€í™˜í•  ë¬¸ìì—´
     * @param hint_type íƒ€ì… íŒíŠ¸ (ê¸°ë³¸ê°’: ìë™ ì¶”ë¡ )
     * @return ë³€í™˜ëœ DataVariant
     */
    inline DataVariant StringToDataVariant(const std::string& str, size_t hint_type = 7) {
        // ìë™ íƒ€ì… ì¶”ë¡ 
        if (hint_type == 7) {  // ìë™ ì¶”ë¡  ëª¨ë“œ
            // ë¶ˆë¦° ì²´í¬
            if (str == "true" || str == "TRUE" || str == "1") return true;
            if (str == "false" || str == "FALSE" || str == "0") return false;
            
            // ìˆ«ì ì²´í¬
            try {
                // ì†Œìˆ˜ì  í¬í•¨ ì—¬ë¶€ í™•ì¸
                if (str.find('.') != std::string::npos) {
                    double d = std::stod(str);
                    float f = static_cast<float>(d);
                    // ì •ë°€ë„ ì†ì‹¤ì´ ì—†ìœ¼ë©´ float ì‚¬ìš©
                    if (std::abs(d - static_cast<double>(f)) < 1e-6) {
                        return f;
                    } else {
                        return d;
                    }
                } else {
                    // ì •ìˆ˜ ì²˜ë¦¬
                    long long ll = std::stoll(str);
                    if (ll >= INT16_MIN && ll <= INT16_MAX) {
                        return static_cast<int16_t>(ll);
                    } else if (ll >= 0 && ll <= UINT16_MAX) {
                        return static_cast<uint16_t>(ll);
                    } else if (ll >= INT32_MIN && ll <= INT32_MAX) {
                        return static_cast<int32_t>(ll);
                    } else if (ll >= 0 && ll <= UINT32_MAX) {
                        return static_cast<uint32_t>(ll);
                    }
                }
            } catch (...) {
                // ìˆ«ì ë³€í™˜ ì‹¤íŒ¨ ì‹œ ë¬¸ìì—´ë¡œ ì²˜ë¦¬
            }
        }
        
        // íŒíŠ¸ ê¸°ë°˜ ë³€í™˜ ë˜ëŠ” ê¸°ë³¸ ë¬¸ìì—´ ë°˜í™˜
        switch (hint_type) {
            case 0: return str == "true" || str == "1";
            case 1: try { return static_cast<int16_t>(std::stoi(str)); } catch (...) { break; }
            case 2: try { return static_cast<uint16_t>(std::stoul(str)); } catch (...) { break; }
            case 3: try { return static_cast<int32_t>(std::stol(str)); } catch (...) { break; }
            case 4: try { return static_cast<uint32_t>(std::stoul(str)); } catch (...) { break; }
            case 5: try { return std::stof(str); } catch (...) { break; }
            case 6: try { return std::stod(str); } catch (...) { break; }
            default: break;
        }
        
        return str;  // ê¸°ë³¸ê°’: ë¬¸ìì—´
    }

    // =========================================================================
    // ğŸ”¥ ë©”ëª¨ë¦¬ ë° ì„±ëŠ¥ ìµœì í™” íƒ€ì…ë“¤
    // =========================================================================
    
    /**
     * @brief ê²½ëŸ‰ ë¬¸ìì—´ ë·° (C++17 í˜¸í™˜)
     * @details ë¬¸ìì—´ ë³µì‚¬ ì—†ì´ ì°¸ì¡°ë§Œ ì œê³µ (ì„±ëŠ¥ ìµœì í™”)
     */
    using StringView = std::string_view;
    
    /**
     * @brief ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° ë³„ì¹­ë“¤
     */
    template<typename T>
    using UniquePtr = std::unique_ptr<T>;
    
    template<typename T>
    using SharedPtr = std::shared_ptr<T>;
    
    template<typename T>
    using WeakPtr = std::weak_ptr<T>;
    
    /**
     * @brief ë²¡í„° ë³„ì¹­ë“¤ (ìì£¼ ì‚¬ìš©ë˜ëŠ” íƒ€ì…ë“¤)
     */
    using StringVector = std::vector<std::string>;
    using UniqueIdVector = std::vector<UniqueId>;
    using DataVariantVector = std::vector<DataVariant>;

    // =========================================================================
    // ğŸ”¥ ê¸°ì¡´ PulseOne í”„ë¡œì íŠ¸ì™€ì˜ í˜¸í™˜ì„± ë³´ì¥
    // =========================================================================
    
    /**
     * @brief ê¸°ì¡´ í”„ë¡œì íŠ¸ í˜¸í™˜ì„±ì„ ìœ„í•œ íƒ€ì… ë³„ì¹­ë“¤
     * @details ê¸°ì¡´ ì½”ë“œê°€ ê³„ì† ì‘ë™í•˜ë„ë¡ ë³´ì¥
     */
    namespace Compatibility {
        // ê¸°ì¡´ ì½”ë“œì—ì„œ ì‚¬ìš©í–ˆì„ ìˆ˜ ìˆëŠ” íƒ€ì…ë“¤
        using DeviceId = UniqueId;
        using PointId = UniqueId;
        using RequestId = UniqueId;
        using Value = DataVariant;
        using TimeStamp = Timestamp;  // ê¸°ì¡´ ìŠ¤íƒ€ì¼
    }

} // namespace BasicTypes
} // namespace PulseOne

#endif // PULSEONE_COMMON_BASIC_TYPES_H