// =============================================================================
// collector/src/Utils/ConfigManager.cpp
// PulseOne í†µí•© ì„¤ì • ê´€ë¦¬ì êµ¬í˜„ - ì™„ì„±ë³¸
// =============================================================================

#include "Utils/ConfigManager.h"
#include "Utils/LogManager.h"
#include <fstream>
#include <sstream>
#include <cstdlib>
#include <algorithm>
#include <filesystem>
#include <iostream>
#include <cstring>

// =============================================================================
// ì‹±ê¸€í†¤ êµ¬í˜„
// =============================================================================

ConfigManager& ConfigManager::getInstance() {
    static ConfigManager instance;
    return instance;
}

// =============================================================================
// ë©”ì¸ ì´ˆê¸°í™” ë¡œì§
// =============================================================================

void ConfigManager::initialize() {
    std::lock_guard<std::mutex> lock(configMutex);
    
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "ğŸ” ConfigManager ì´ˆê¸°í™” ì‹œì‘...");
    
    // 1. ì„¤ì • ë””ë ‰í† ë¦¬ ì°¾ê¸° (í™˜ê²½ë³€ìˆ˜ ìš°ì„ )
    configDir_ = findConfigDirectory();
    if (configDir_.empty()) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::ERROR, 
            "âŒ ì„¤ì • ë””ë ‰í† ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!");
        return;
    }
    
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "âœ… ì„¤ì • ë””ë ‰í† ë¦¬: " + configDir_);
    
    // 2. ì„¤ì • íŒŒì¼ë“¤ ì¡´ì¬ í™•ì¸ ë° ìƒì„± (ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰)
    try {
        ensureConfigFilesExist();
    } catch (const std::exception& e) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "âš ï¸ ì„¤ì • íŒŒì¼ ìƒì„± ì¤‘ ì˜¤ë¥˜ (ê³„ì† ì§„í–‰): " + std::string(e.what()));
    }
    
    // 3. ë°ì´í„° ë””ë ‰í† ë¦¬ ì„¤ì •
    dataDir_ = findDataDirectory();
    try {
        ensureDataDirectories();
    } catch (const std::exception& e) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "âš ï¸ ë°ì´í„° ë””ë ‰í† ë¦¬ ìƒì„± ì¤‘ ì˜¤ë¥˜ (ê³„ì† ì§„í–‰): " + std::string(e.what()));
    }
    
    // 4. ê¸°ì¡´ í˜¸í™˜ì„±ì„ ìœ„í•œ envFilePath ì„¤ì •
    envFilePath = configDir_ + "/.env";
    
    // 5. ì„¤ì • íŒŒì¼ë“¤ ë¡œë“œ
    loadMainConfig();
    loadAdditionalConfigs();
    
    // 6. ë³€ìˆ˜ í™•ì¥
    expandAllVariables();
    
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "âœ… ConfigManager ì´ˆê¸°í™” ì™„ë£Œ - " + std::to_string(configMap.size()) + "ê°œ ì„¤ì • ë¡œë“œë¨");
}

void ConfigManager::reload() {
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "ğŸ”„ ConfigManager ì¬ë¡œë”© ì‹œì‘...");
    
    // ê¸°ì¡´ ì„¤ì • í´ë¦¬ì–´
    {
        std::lock_guard<std::mutex> lock(configMutex);
        configMap.clear();
        loadedFiles_.clear();
        searchLog_.clear();
    }
    
    // ë‹¤ì‹œ ì´ˆê¸°í™”
    initialize();
}

// =============================================================================
// ìŠ¤ë§ˆíŠ¸ ê²½ë¡œ ì°¾ê¸° (í™˜ê²½ë³€ìˆ˜ ìš°ì„ )
// =============================================================================

std::string ConfigManager::findConfigDirectory() {
    searchLog_.clear();
    
    // 1. í™˜ê²½ë³€ìˆ˜ í™•ì¸ (ìµœìš°ì„ )
    const char* env_config = std::getenv("PULSEONE_CONFIG_DIR");
    if (env_config && strlen(env_config) > 0 && directoryExists(env_config)) {
        searchLog_.push_back("âœ… í™˜ê²½ë³€ìˆ˜: " + std::string(env_config));
        return std::string(env_config);
    } else if (env_config) {
        searchLog_.push_back("âŒ í™˜ê²½ë³€ìˆ˜ (ì¡´ì¬í•˜ì§€ ì•ŠìŒ): " + std::string(env_config));
    }
    
    // 2. ì‹¤í–‰íŒŒì¼ ê¸°ì¤€ í›„ë³´ ê²½ë¡œë“¤
    std::string exe_dir = getExecutableDirectory();
    std::vector<std::string> candidates;
    
    if (!exe_dir.empty()) {
        candidates.push_back(exe_dir + "/../config");      // bin/../config (ì¼ë°˜ì )
        candidates.push_back(exe_dir + "/../../config");   // bin/debug/../config (ê°œë°œí™˜ê²½)
        candidates.push_back(exe_dir + "/config");         // bin/config
    }
    
    // 3. í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬ ê¸°ì¤€
    candidates.push_back("./config");
    candidates.push_back("../config");
    candidates.push_back("../../config");
    
    // 4. ì ˆëŒ€ ê²½ë¡œë“¤ (ë¦¬ëˆ…ìŠ¤ í‘œì¤€)
#ifndef _WIN32
    candidates.push_back("/opt/pulseone/config");
    candidates.push_back("/etc/pulseone");
    candidates.push_back("/usr/local/etc/pulseone");
#endif
    
    // 5. ê° í›„ë³´ ê²½ë¡œ ê²€ì‚¬
    for (const auto& candidate : candidates) {
        try {
            if (directoryExists(candidate)) {
                std::string canonical_path = std::filesystem::canonical(candidate).string();
                searchLog_.push_back("âœ… ë°œê²¬: " + candidate + " â†’ " + canonical_path);
                return canonical_path;
            } else {
                searchLog_.push_back("âŒ ì—†ìŒ: " + candidate);
            }
        } catch (const std::exception& e) {
            searchLog_.push_back("âŒ ì˜¤ë¥˜: " + candidate + " (" + e.what() + ")");
        }
    }
    
    searchLog_.push_back("âŒ ëª¨ë“  í›„ë³´ ê²½ë¡œì—ì„œ config ë””ë ‰í† ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ");
    return "";
}

std::string ConfigManager::getExecutablePath() {
#ifdef _WIN32
    char path[MAX_PATH];
    DWORD length = GetModuleFileNameA(NULL, path, MAX_PATH);
    if (length > 0 && length < MAX_PATH) {
        return std::string(path);
    }
    return "";
#else
    char path[1024];
    ssize_t count = readlink("/proc/self/exe", path, sizeof(path) - 1);
    if (count != -1) {
        path[count] = '\0';
        return std::string(path);
    }
    return "";
#endif
}

std::string ConfigManager::getExecutableDirectory() {
    std::string exe_path = getExecutablePath();
    if (exe_path.empty()) {
        return "";
    }
    
    return getDirectoryFromPath(exe_path);
}

std::string ConfigManager::getDirectoryFromPath(const std::string& path) {
    try {
        return std::filesystem::path(path).parent_path().string();
    } catch (const std::exception&) {
        // í´ë°±: ìˆ˜ë™ìœ¼ë¡œ ë””ë ‰í† ë¦¬ ì¶”ì¶œ
        size_t last_slash = path.find_last_of("/\\");
        if (last_slash != std::string::npos) {
            return path.substr(0, last_slash);
        }
        return "";
    }
}

bool ConfigManager::directoryExists(const std::string& path) {
    try {
        return std::filesystem::exists(path) && std::filesystem::is_directory(path);
    } catch (const std::exception&) {
        return false;
    }
}

// =============================================================================
// ì„¤ì • íŒŒì¼ ë¡œë”©
// =============================================================================

void ConfigManager::loadMainConfig() {
    std::string main_env_path = configDir_ + "/.env";
    
    if (std::filesystem::exists(main_env_path)) {
        loadConfigFile(main_env_path);
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
            "âœ… ë©”ì¸ ì„¤ì • ë¡œë“œ: .env");
    } else {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "âš ï¸ ë©”ì¸ ì„¤ì • íŒŒì¼ ì—†ìŒ: .env");
    }
}

void ConfigManager::loadAdditionalConfigs() {
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "ğŸ” ì¶”ê°€ ì„¤ì • íŒŒì¼ í™•ì¸ ì‹œì‘");
    
    // CONFIG_FILESì—ì„œ ì¶”ê°€ íŒŒì¼ ëª©ë¡ ì½ê¸°
    std::string config_files = getOrDefault("CONFIG_FILES", "");
    
    if (config_files.empty()) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
            "â„¹ï¸ ì¶”ê°€ ì„¤ì • íŒŒì¼ ì—†ìŒ (CONFIG_FILES ë¹„ì–´ìˆìŒ)");
        return;
    }
    
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "ğŸ” ì¶”ê°€ ì„¤ì • íŒŒì¼ ëª©ë¡: " + config_files);
    
    // ì•ˆì „í•œ ì½¤ë§ˆ ë¶„ë¦¬ (ë¬´í•œë£¨í”„ ë°©ì§€)
    std::vector<std::string> file_list;
    std::string current_file;
    
    for (size_t i = 0; i < config_files.length() && file_list.size() < 10; ++i) {
        char c = config_files[i];
        
        if (c == ',') {
            // ê³µë°± ì œê±° í›„ ì¶”ê°€
            current_file.erase(0, current_file.find_first_not_of(" \t"));
            current_file.erase(current_file.find_last_not_of(" \t") + 1);
            
            if (!current_file.empty()) {
                file_list.push_back(current_file);
            }
            current_file.clear();
        } else {
            current_file += c;
        }
    }
    
    // ë§ˆì§€ë§‰ íŒŒì¼ ì¶”ê°€
    if (!current_file.empty() && file_list.size() < 10) {
        current_file.erase(0, current_file.find_first_not_of(" \t"));
        current_file.erase(current_file.find_last_not_of(" \t") + 1);
        if (!current_file.empty()) {
            file_list.push_back(current_file);
        }
    }
    
    // ê° íŒŒì¼ ë¡œë“œ ì‹œë„
    for (const auto& filename : file_list) {
        std::string full_path = configDir_ + "/" + filename;
        
        try {
            if (std::filesystem::exists(full_path)) {
                loadConfigFile(full_path);
                PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
                    "âœ… ì¶”ê°€ ì„¤ì • ë¡œë“œ: " + filename);
            } else {
                PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
                    "â„¹ï¸ ì¶”ê°€ ì„¤ì • íŒŒì¼ ì—†ìŒ: " + filename);
            }
        } catch (const std::exception& e) {
            PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
                "âš ï¸ ì„¤ì • íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨: " + filename + " - " + e.what());
        }
    }
    
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "âœ… ì¶”ê°€ ì„¤ì • íŒŒì¼ í™•ì¸ ì™„ë£Œ");
}

void ConfigManager::loadConfigFile(const std::string& filepath) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::ERROR, 
            "âŒ íŒŒì¼ ì—´ê¸° ì‹¤íŒ¨: " + filepath);
        return;
    }
    
    std::string line;
    int line_count = 0;
    int parsed_count = 0;
    
    while (std::getline(file, line)) {
        line_count++;
        
        size_t original_size = configMap.size();
        parseLine(line);
        
        if (configMap.size() > original_size) {
            parsed_count++;
        }
    }
    
    file.close();
    loadedFiles_.push_back(filepath);
    
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "ğŸ“„ " + filepath + " - " + std::to_string(parsed_count) + "/" + 
        std::to_string(line_count) + " ë¼ì¸ íŒŒì‹±ë¨");
}

// =============================================================================
// ë³€ìˆ˜ í™•ì¥ (${VAR} í˜•íƒœ)
// =============================================================================

void ConfigManager::expandAllVariables() {
    // ì—¬ëŸ¬ ë²ˆ ë°˜ë³µí•´ì„œ ì¤‘ì²©ëœ ë³€ìˆ˜ë„ í™•ì¥
    bool changed = true;
    int max_iterations = 5;  // ë¬´í•œë£¨í”„ ë°©ì§€
    
    for (int i = 0; i < max_iterations && changed; ++i) {
        changed = false;
        
        for (auto& [key, value] : configMap) {
            std::string expanded = expandVariables(value);
            if (expanded != value) {
                value = expanded;
                changed = true;
            }
        }
    }
    
    if (changed) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "âš ï¸ ë³€ìˆ˜ í™•ì¥ì´ " + std::to_string(max_iterations) + 
            "ë²ˆ ë°˜ë³µ í›„ì—ë„ ì™„ë£Œë˜ì§€ ì•ŠìŒ (ìˆœí™˜ ì°¸ì¡° ê°€ëŠ¥ì„±)");
    }
}

std::string ConfigManager::expandVariables(const std::string& value) const {
    std::string result = value;
    size_t pos = 0;
    int max_replacements = 10;  // ë¬´í•œë£¨í”„ ë°©ì§€
    
    while ((pos = result.find("${", pos)) != std::string::npos && max_replacements-- > 0) {
        size_t end_pos = result.find("}", pos + 2);
        if (end_pos == std::string::npos) {
            break; // ë‹«ëŠ” ê´„í˜¸ê°€ ì—†ìŒ
        }
        
        std::string var_name = result.substr(pos + 2, end_pos - pos - 2);
        std::string var_value;
        
        // 1. ë¨¼ì € configMapì—ì„œ ì°¾ê¸°
        auto it = configMap.find(var_name);
        if (it != configMap.end()) {
            var_value = it->second;
        } else {
            // 2. í™˜ê²½ë³€ìˆ˜ì—ì„œ ì°¾ê¸°
            const char* env_value = std::getenv(var_name.c_str());
            if (env_value) {
                var_value = std::string(env_value);
            }
        }
        
        // 3. ì¹˜í™˜
        result.replace(pos, end_pos - pos + 1, var_value);
        pos += var_value.length();
    }
    
    return result;
}

// =============================================================================
// ê¸°ë³¸ ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ (100% í˜¸í™˜)
// =============================================================================

void ConfigManager::parseLine(const std::string& line) {
    if (line.empty() || line[0] == '#') return;

    size_t eqPos = line.find('=');
    if (eqPos == std::string::npos) return;

    std::string key = line.substr(0, eqPos);
    std::string value = line.substr(eqPos + 1);

    // ì•ë’¤ ê³µë°± ì œê±°
    key.erase(std::remove_if(key.begin(), key.end(), ::isspace), key.end());
    
    // ê°’ì˜ ì•ë’¤ ê³µë°± ë° ë”°ì˜´í‘œ ì œê±°
    value.erase(0, value.find_first_not_of(" \t"));
    value.erase(value.find_last_not_of(" \t") + 1);
    value.erase(std::remove(value.begin(), value.end(), '\"'), value.end());

    if (!key.empty()) {
        configMap[key] = value;
    }
}

std::string ConfigManager::get(const std::string& key) const {
    std::lock_guard<std::mutex> lock(configMutex);
    auto it = configMap.find(key);
    return (it != configMap.end()) ? it->second : "";
}

std::string ConfigManager::getOrDefault(const std::string& key, const std::string& defaultValue) const {
    std::lock_guard<std::mutex> lock(configMutex);
    auto it = configMap.find(key);
    return (it != configMap.end()) ? it->second : defaultValue;
}

void ConfigManager::set(const std::string& key, const std::string& value) {
    std::lock_guard<std::mutex> lock(configMutex);
    configMap[key] = value;
}

bool ConfigManager::hasKey(const std::string& key) const {
    std::lock_guard<std::mutex> lock(configMutex);
    return configMap.find(key) != configMap.end();
}

std::map<std::string, std::string> ConfigManager::listAll() const {
    std::lock_guard<std::mutex> lock(configMutex);
    return configMap;
}

// =============================================================================
// íƒ€ì…ë³„ ì„¤ì •ê°’ ì¡°íšŒ (í¸ì˜ ê¸°ëŠ¥)
// =============================================================================

int ConfigManager::getInt(const std::string& key, int defaultValue) const {
    std::string value = get(key);
    if (value.empty()) {
        return defaultValue;
    }
    
    try {
        return std::stoi(value);
    } catch (const std::exception&) {
        return defaultValue;
    }
}

bool ConfigManager::getBool(const std::string& key, bool defaultValue) const {
    std::string value = get(key);
    if (value.empty()) {
        return defaultValue;
    }
    
    // true, yes, 1, onì„ trueë¡œ ì¸ì‹
    std::transform(value.begin(), value.end(), value.begin(), ::tolower);
    return (value == "true" || value == "yes" || value == "1" || value == "on");
}

double ConfigManager::getDouble(const std::string& key, double defaultValue) const {
    std::string value = get(key);
    if (value.empty()) {
        return defaultValue;
    }
    
    try {
        return std::stod(value);
    } catch (const std::exception&) {
        return defaultValue;
    }
}

// =============================================================================
// ë””ë²„ê¹… ë„êµ¬
// =============================================================================

void ConfigManager::printConfigSearchLog() const {
    std::cout << "\nğŸ” ConfigManager ê²½ë¡œ ê²€ìƒ‰ ë¡œê·¸:\n";
    std::cout << "================================================\n";
    
    for (const auto& log_entry : searchLog_) {
        std::cout << log_entry << "\n";
    }
    
    std::cout << "\nğŸ“„ ë¡œë“œëœ ì„¤ì • íŒŒì¼ë“¤:\n";
    for (const auto& file : loadedFiles_) {
        std::cout << "  " << file << "\n";
    }
    
    std::cout << "\nâš™ï¸ ì´ " << configMap.size() << "ê°œ ì„¤ì • í•­ëª© ë¡œë“œë¨\n";
    std::cout << "================================================\n\n";
}

// =============================================================================
// í…œí”Œë¦¿ ìƒì„± ê¸°ëŠ¥ë“¤ (ê°„ì†Œí™” ë²„ì „)
// =============================================================================

void ConfigManager::ensureConfigFilesExist() {
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "ğŸ” ì„¤ì • íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ ì¤‘...");
    
    try {
        // ë©”ì¸ .env íŒŒì¼ë§Œ í™•ì¸/ìƒì„±
        std::string main_env_path = configDir_ + "/.env";
        if (!std::filesystem::exists(main_env_path)) {
            PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
                "âš ï¸ ë©”ì¸ ì„¤ì • íŒŒì¼ ì—†ìŒ, ê¸°ë³¸ í…œí”Œë¦¿ ìƒì„±: .env");
            createMainEnvFile();
        } else {
            PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
                "âœ… ë©”ì¸ ì„¤ì • íŒŒì¼ ì¡´ì¬: .env");
        }
        
        // ê¸°ë³¸ ì¶”ê°€ íŒŒì¼ë“¤ë„ ìƒì„± (ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰)
        createDefaultConfigFiles();
        
    } catch (const std::exception& e) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "âš ï¸ ì„¤ì • íŒŒì¼ í™•ì¸ ì¤‘ ì˜¤ë¥˜: " + std::string(e.what()) + " (ê³„ì† ì§„í–‰)");
    }
}

void ConfigManager::createDefaultConfigFiles() {
    try {
        createSecretsDirectory();
        createDatabaseEnvFile();
        createRedisEnvFile();
        createTimeseriesEnvFile();
        createMessagingEnvFile();
        
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
            "âœ… ê¸°ë³¸ ì„¤ì • íŒŒì¼ë“¤ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.");
            
    } catch (const std::exception& e) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "âš ï¸ ì¶”ê°€ ì„¤ì • íŒŒì¼ ìƒì„± ì‹¤íŒ¨: " + std::string(e.what()));
    }
}

void ConfigManager::createMainEnvFile() {
    std::string content = R"(# =============================================================================
# PulseOne ë©”ì¸ ì„¤ì • íŒŒì¼ (.env) - ìë™ ìƒì„±ë¨
# =============================================================================

# í™˜ê²½ ì„¤ì •
NODE_ENV=development
LOG_LEVEL=info

# ê¸°ë³¸ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
DATABASE_TYPE=SQLITE

# ê¸°ë³¸ ë””ë ‰í† ë¦¬ ì„¤ì •
DATA_DIR=./data

# ì‹œìŠ¤í…œ ì„¤ì •
MAX_WORKER_THREADS=4
DEFAULT_TIMEOUT_MS=5000

# ì¶”ê°€ ì„¤ì • íŒŒì¼ë“¤ (ì„ íƒì )
CONFIG_FILES=database.env,redis.env,timeseries.env,messaging.env
)";
    
    createFileFromTemplate(configDir_ + "/.env", content);
}

void ConfigManager::createDatabaseEnvFile() {
    std::string content = R"(# =============================================================================
# ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì • (database.env) - ìë™ ìƒì„±ë¨
# =============================================================================

# ë©”ì¸ ë°ì´í„°ë² ì´ìŠ¤ íƒ€ì… ì„ íƒ
DATABASE_TYPE=SQLITE

# SQLite ì„¤ì • (ê¸°ë³¸ê°’)
SQLITE_PATH=${DATA_DIR}/db/pulseone.db
SQLITE_BACKUP_PATH=${DATA_DIR}/backup/
SQLITE_LOGS_PATH=${DATA_DIR}/logs/

# SQLite ì„±ëŠ¥ ì„¤ì •
SQLITE_JOURNAL_MODE=WAL
SQLITE_SYNCHRONOUS=NORMAL
SQLITE_CACHE_SIZE=2000
SQLITE_BUSY_TIMEOUT_MS=5000
SQLITE_FOREIGN_KEYS=true

# PostgreSQL ì„¤ì • (í•„ìš”ì‹œ í™œì„±í™”)
# POSTGRES_PRIMARY_HOST=localhost
# POSTGRES_PRIMARY_PORT=5432
# POSTGRES_PRIMARY_DB=pulseone_main
# POSTGRES_PRIMARY_USER=postgres
)";

    createFileFromTemplate(configDir_ + "/database.env", content);
}

void ConfigManager::createRedisEnvFile() {
    std::string content = R"(# =============================================================================
# Redis ì„¤ì • (redis.env) - ìë™ ìƒì„±ë¨
# =============================================================================

# Primary Redis ì„œë²„
REDIS_PRIMARY_HOST=localhost
REDIS_PRIMARY_PORT=6379
REDIS_PRIMARY_DB=0
REDIS_PRIMARY_SSL=false

# Redis ì—°ê²° ì„¤ì •
REDIS_CONNECTION_TIMEOUT=5000
REDIS_MAX_CONNECTIONS=20
REDIS_RETRY_ATTEMPTS=3
)";

    createFileFromTemplate(configDir_ + "/redis.env", content);
}

void ConfigManager::createTimeseriesEnvFile() {
    std::string content = R"(# =============================================================================
# ì‹œê³„ì—´ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì • (timeseries.env) - ìë™ ìƒì„±ë¨
# =============================================================================

# InfluxDB ì„¤ì •
INFLUX_HOST=localhost
INFLUX_PORT=8086
INFLUX_ORG=pulseone
INFLUX_BUCKET=telemetry_data
INFLUX_SSL=false

# InfluxDB ì„±ëŠ¥ ì„¤ì •
INFLUX_BATCH_SIZE=1000
INFLUX_FLUSH_INTERVAL_SEC=10
INFLUX_RETRY_INTERVAL_SEC=5
INFLUX_MAX_RETRIES=3
)";

    createFileFromTemplate(configDir_ + "/timeseries.env", content);
}

void ConfigManager::createMessagingEnvFile() {
    std::string content = R"(# =============================================================================
# ë©”ì‹œì§• ì‹œìŠ¤í…œ ì„¤ì • (messaging.env) - ìë™ ìƒì„±ë¨
# =============================================================================

# RabbitMQ ì„¤ì •
RABBITMQ_HOST=localhost
RABBITMQ_PORT=5672
RABBITMQ_MANAGEMENT_PORT=15672
RABBITMQ_USER=admin
RABBITMQ_VHOST=pulseone
RABBITMQ_SSL=false

# RabbitMQ ì—°ê²° ì„¤ì •
RABBITMQ_CONNECTION_TIMEOUT=30
RABBITMQ_HEARTBEAT_INTERVAL=60
RABBITMQ_MAX_CHANNELS=100
RABBITMQ_AUTO_RECOVERY=true
)";

    createFileFromTemplate(configDir_ + "/messaging.env", content);
}

void ConfigManager::createSecretsDirectory() {
    std::string secrets_dir = configDir_ + "/secrets";
    
    try {
        if (std::filesystem::exists(secrets_dir)) {
            return;
        }
        
        std::filesystem::create_directories(secrets_dir);
        
        // README íŒŒì¼ ìƒì„±
        std::string readme_content = R"(# Secrets Directory

ì´ ë””ë ‰í† ë¦¬ëŠ” ì•”í˜¸í™”ëœ ë¹„ë°€ë²ˆí˜¸ íŒŒì¼ë“¤ì„ ì €ì¥í•©ë‹ˆë‹¤.

## ìƒì„±í•´ì•¼ í•  íŒŒì¼ë“¤ (ì˜ˆì‹œ)
- postgres_primary.key
- redis_primary.key  
- influx_token.key
- rabbitmq.key
)";

        createFileFromTemplate(secrets_dir + "/README.md", readme_content);
        createFileFromTemplate(secrets_dir + "/.gitignore", "*\n!README.md\n!.gitignore\n");
        
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
            "âœ… Secrets ë””ë ‰í† ë¦¬ ìƒì„±: " + secrets_dir);
            
    } catch (const std::exception& e) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "âš ï¸ Secrets ë””ë ‰í† ë¦¬ ìƒì„± ì‹¤íŒ¨: " + std::string(e.what()));
    }
}

bool ConfigManager::createFileFromTemplate(const std::string& filepath, const std::string& content) {
    try {
        // íŒŒì¼ì´ ì´ë¯¸ ì¡´ì¬í•˜ë©´ ìƒì„±í•˜ì§€ ì•ŠìŒ
        if (std::filesystem::exists(filepath)) {
            return true;
        }
        
        std::ofstream file(filepath);
        if (!file.is_open()) {
            return false;
        }
        
        file << content;
        file.close();
        
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
            "âœ… ì„¤ì • íŒŒì¼ ìƒì„±: " + std::filesystem::path(filepath).filename().string());
        
        return true;
        
    } catch (const std::exception& e) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "âš ï¸ íŒŒì¼ ìƒì„± ì¤‘ ì˜ˆì™¸: " + std::string(e.what()));
        return false;
    }
}

// =============================================================================
// ë°ì´í„° ê²½ë¡œ ê´€ë ¨
// =============================================================================

std::string ConfigManager::findDataDirectory() {
    // 1. í™˜ê²½ë³€ìˆ˜ ìµœìš°ì„  í™•ì¸
    const char* env_data = std::getenv("PULSEONE_DATA_DIR");
    if (env_data && strlen(env_data) > 0) {
        return std::string(env_data);
    }
    
    // 2. ì„¤ì •íŒŒì¼ì—ì„œ í™•ì¸
    std::string config_data = get("DATA_DIR");
    if (!config_data.empty()) {
        return expandVariables(config_data);
    }
    
    // 3. ê¸°ë³¸ ê²½ë¡œ ì‚¬ìš©
    return "./data";
}

void ConfigManager::ensureDataDirectories() {
    if (dataDir_.empty()) {
        return;
    }
    
    std::vector<std::string> dirs = {"db", "logs", "backup", "temp"};
    
    for (const auto& dir : dirs) {
        try {
            std::string full_path = dataDir_ + "/" + dir;
            std::filesystem::create_directories(full_path);
        } catch (const std::exception&) {
            // ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
        }
    }
}

// =============================================================================
// í¸ì˜ ë©”ì„œë“œë“¤
// =============================================================================

std::string ConfigManager::getDataDirectory() const {
    return dataDir_.empty() ? "./data" : dataDir_;
}

std::string ConfigManager::getSQLiteDbPath() const {
    std::string sqlite_path = get("SQLITE_PATH");
    if (!sqlite_path.empty()) {
        return expandVariables(sqlite_path);
    }
    return getDataDirectory() + "/db/pulseone.db";
}

std::string ConfigManager::getBackupDirectory() const {
    std::string backup_path = get("SQLITE_BACKUP_PATH");
    if (!backup_path.empty()) {
        return expandVariables(backup_path);
    }
    return getDataDirectory() + "/backup";
}