// =============================================================================
// collector/src/Utils/ConfigManager.cpp
// PulseOne 통합 설정 관리자 구현 - 완성본
// =============================================================================

#include "Utils/ConfigManager.h"
#include "Utils/LogManager.h"
#include <fstream>
#include <sstream>
#include <cstdlib>
#include <algorithm>
#include <filesystem>
#include <iostream>
#include <cstring>

// =============================================================================
// 싱글톤 구현
// =============================================================================

ConfigManager& ConfigManager::getInstance() {
    static ConfigManager instance;
    return instance;
}

// =============================================================================
// 메인 초기화 로직
// =============================================================================

void ConfigManager::initialize() {
    std::lock_guard<std::mutex> lock(configMutex);
    
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "🔍 ConfigManager 초기화 시작...");
    
    // 1. 설정 디렉토리 찾기 (환경변수 우선)
    configDir_ = findConfigDirectory();
    if (configDir_.empty()) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::ERROR, 
            "❌ 설정 디렉토리를 찾을 수 없습니다!");
        return;
    }
    
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "✅ 설정 디렉토리: " + configDir_);
    
    // 2. 설정 파일들 존재 확인 및 생성 (실패해도 계속 진행)
    try {
        ensureConfigFilesExist();
    } catch (const std::exception& e) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "⚠️ 설정 파일 생성 중 오류 (계속 진행): " + std::string(e.what()));
    }
    
    // 3. 데이터 디렉토리 설정
    dataDir_ = findDataDirectory();
    try {
        ensureDataDirectories();
    } catch (const std::exception& e) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "⚠️ 데이터 디렉토리 생성 중 오류 (계속 진행): " + std::string(e.what()));
    }
    
    // 4. 기존 호환성을 위한 envFilePath 설정
    envFilePath = configDir_ + "/.env";
    
    // 5. 설정 파일들 로드
    loadMainConfig();
    loadAdditionalConfigs();
    
    // 6. 변수 확장
    expandAllVariables();
    
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "✅ ConfigManager 초기화 완료 - " + std::to_string(configMap.size()) + "개 설정 로드됨");
}

void ConfigManager::reload() {
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "🔄 ConfigManager 재로딩 시작...");
    
    // 기존 설정 클리어
    {
        std::lock_guard<std::mutex> lock(configMutex);
        configMap.clear();
        loadedFiles_.clear();
        searchLog_.clear();
    }
    
    // 다시 초기화
    initialize();
}

// =============================================================================
// 스마트 경로 찾기 (환경변수 우선)
// =============================================================================

std::string ConfigManager::findConfigDirectory() {
    searchLog_.clear();
    
    // 1. 환경변수 확인 (최우선)
    const char* env_config = std::getenv("PULSEONE_CONFIG_DIR");
    if (env_config && strlen(env_config) > 0 && directoryExists(env_config)) {
        searchLog_.push_back("✅ 환경변수: " + std::string(env_config));
        return std::string(env_config);
    } else if (env_config) {
        searchLog_.push_back("❌ 환경변수 (존재하지 않음): " + std::string(env_config));
    }
    
    // 2. 실행파일 기준 후보 경로들
    std::string exe_dir = getExecutableDirectory();
    std::vector<std::string> candidates;
    
    if (!exe_dir.empty()) {
        candidates.push_back(exe_dir + "/../config");      // bin/../config (일반적)
        candidates.push_back(exe_dir + "/../../config");   // bin/debug/../config (개발환경)
        candidates.push_back(exe_dir + "/config");         // bin/config
    }
    
    // 3. 현재 작업 디렉토리 기준
    candidates.push_back("./config");
    candidates.push_back("../config");
    candidates.push_back("../../config");
    
    // 4. 절대 경로들 (리눅스 표준)
#ifndef _WIN32
    candidates.push_back("/opt/pulseone/config");
    candidates.push_back("/etc/pulseone");
    candidates.push_back("/usr/local/etc/pulseone");
#endif
    
    // 5. 각 후보 경로 검사
    for (const auto& candidate : candidates) {
        try {
            if (directoryExists(candidate)) {
                std::string canonical_path = std::filesystem::canonical(candidate).string();
                searchLog_.push_back("✅ 발견: " + candidate + " → " + canonical_path);
                return canonical_path;
            } else {
                searchLog_.push_back("❌ 없음: " + candidate);
            }
        } catch (const std::exception& e) {
            searchLog_.push_back("❌ 오류: " + candidate + " (" + e.what() + ")");
        }
    }
    
    searchLog_.push_back("❌ 모든 후보 경로에서 config 디렉토리를 찾을 수 없음");
    return "";
}

std::string ConfigManager::getExecutablePath() {
#ifdef _WIN32
    char path[MAX_PATH];
    DWORD length = GetModuleFileNameA(NULL, path, MAX_PATH);
    if (length > 0 && length < MAX_PATH) {
        return std::string(path);
    }
    return "";
#else
    char path[1024];
    ssize_t count = readlink("/proc/self/exe", path, sizeof(path) - 1);
    if (count != -1) {
        path[count] = '\0';
        return std::string(path);
    }
    return "";
#endif
}

std::string ConfigManager::getExecutableDirectory() {
    std::string exe_path = getExecutablePath();
    if (exe_path.empty()) {
        return "";
    }
    
    return getDirectoryFromPath(exe_path);
}

std::string ConfigManager::getDirectoryFromPath(const std::string& path) {
    try {
        return std::filesystem::path(path).parent_path().string();
    } catch (const std::exception&) {
        // 폴백: 수동으로 디렉토리 추출
        size_t last_slash = path.find_last_of("/\\");
        if (last_slash != std::string::npos) {
            return path.substr(0, last_slash);
        }
        return "";
    }
}

bool ConfigManager::directoryExists(const std::string& path) {
    try {
        return std::filesystem::exists(path) && std::filesystem::is_directory(path);
    } catch (const std::exception&) {
        return false;
    }
}

// =============================================================================
// 설정 파일 로딩
// =============================================================================

void ConfigManager::loadMainConfig() {
    std::string main_env_path = configDir_ + "/.env";
    
    if (std::filesystem::exists(main_env_path)) {
        loadConfigFile(main_env_path);
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
            "✅ 메인 설정 로드: .env");
    } else {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "⚠️ 메인 설정 파일 없음: .env");
    }
}

void ConfigManager::loadAdditionalConfigs() {
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "🔍 추가 설정 파일 확인 시작");
    
    // CONFIG_FILES에서 추가 파일 목록 읽기
    std::string config_files = getOrDefault("CONFIG_FILES", "");
    
    if (config_files.empty()) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
            "ℹ️ 추가 설정 파일 없음 (CONFIG_FILES 비어있음)");
        return;
    }
    
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "🔍 추가 설정 파일 목록: " + config_files);
    
    // 안전한 콤마 분리 (무한루프 방지)
    std::vector<std::string> file_list;
    std::string current_file;
    
    for (size_t i = 0; i < config_files.length() && file_list.size() < 10; ++i) {
        char c = config_files[i];
        
        if (c == ',') {
            // 공백 제거 후 추가
            current_file.erase(0, current_file.find_first_not_of(" \t"));
            current_file.erase(current_file.find_last_not_of(" \t") + 1);
            
            if (!current_file.empty()) {
                file_list.push_back(current_file);
            }
            current_file.clear();
        } else {
            current_file += c;
        }
    }
    
    // 마지막 파일 추가
    if (!current_file.empty() && file_list.size() < 10) {
        current_file.erase(0, current_file.find_first_not_of(" \t"));
        current_file.erase(current_file.find_last_not_of(" \t") + 1);
        if (!current_file.empty()) {
            file_list.push_back(current_file);
        }
    }
    
    // 각 파일 로드 시도
    for (const auto& filename : file_list) {
        std::string full_path = configDir_ + "/" + filename;
        
        try {
            if (std::filesystem::exists(full_path)) {
                loadConfigFile(full_path);
                PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
                    "✅ 추가 설정 로드: " + filename);
            } else {
                PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
                    "ℹ️ 추가 설정 파일 없음: " + filename);
            }
        } catch (const std::exception& e) {
            PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
                "⚠️ 설정 파일 로드 실패: " + filename + " - " + e.what());
        }
    }
    
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "✅ 추가 설정 파일 확인 완료");
}

void ConfigManager::loadConfigFile(const std::string& filepath) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::ERROR, 
            "❌ 파일 열기 실패: " + filepath);
        return;
    }
    
    std::string line;
    int line_count = 0;
    int parsed_count = 0;
    
    while (std::getline(file, line)) {
        line_count++;
        
        size_t original_size = configMap.size();
        parseLine(line);
        
        if (configMap.size() > original_size) {
            parsed_count++;
        }
    }
    
    file.close();
    loadedFiles_.push_back(filepath);
    
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "📄 " + filepath + " - " + std::to_string(parsed_count) + "/" + 
        std::to_string(line_count) + " 라인 파싱됨");
}

// =============================================================================
// 변수 확장 (${VAR} 형태)
// =============================================================================

void ConfigManager::expandAllVariables() {
    // 여러 번 반복해서 중첩된 변수도 확장
    bool changed = true;
    int max_iterations = 5;  // 무한루프 방지
    
    for (int i = 0; i < max_iterations && changed; ++i) {
        changed = false;
        
        for (auto& [key, value] : configMap) {
            std::string expanded = expandVariables(value);
            if (expanded != value) {
                value = expanded;
                changed = true;
            }
        }
    }
    
    if (changed) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "⚠️ 변수 확장이 " + std::to_string(max_iterations) + 
            "번 반복 후에도 완료되지 않음 (순환 참조 가능성)");
    }
}

std::string ConfigManager::expandVariables(const std::string& value) const {
    std::string result = value;
    size_t pos = 0;
    int max_replacements = 10;  // 무한루프 방지
    
    while ((pos = result.find("${", pos)) != std::string::npos && max_replacements-- > 0) {
        size_t end_pos = result.find("}", pos + 2);
        if (end_pos == std::string::npos) {
            break; // 닫는 괄호가 없음
        }
        
        std::string var_name = result.substr(pos + 2, end_pos - pos - 2);
        std::string var_value;
        
        // 1. 먼저 configMap에서 찾기
        auto it = configMap.find(var_name);
        if (it != configMap.end()) {
            var_value = it->second;
        } else {
            // 2. 환경변수에서 찾기
            const char* env_value = std::getenv(var_name.c_str());
            if (env_value) {
                var_value = std::string(env_value);
            }
        }
        
        // 3. 치환
        result.replace(pos, end_pos - pos + 1, var_value);
        pos += var_value.length();
    }
    
    return result;
}

// =============================================================================
// 기본 인터페이스 구현 (100% 호환)
// =============================================================================

void ConfigManager::parseLine(const std::string& line) {
    if (line.empty() || line[0] == '#') return;

    size_t eqPos = line.find('=');
    if (eqPos == std::string::npos) return;

    std::string key = line.substr(0, eqPos);
    std::string value = line.substr(eqPos + 1);

    // 앞뒤 공백 제거
    key.erase(std::remove_if(key.begin(), key.end(), ::isspace), key.end());
    
    // 값의 앞뒤 공백 및 따옴표 제거
    value.erase(0, value.find_first_not_of(" \t"));
    value.erase(value.find_last_not_of(" \t") + 1);
    value.erase(std::remove(value.begin(), value.end(), '\"'), value.end());

    if (!key.empty()) {
        configMap[key] = value;
    }
}

std::string ConfigManager::get(const std::string& key) const {
    std::lock_guard<std::mutex> lock(configMutex);
    auto it = configMap.find(key);
    return (it != configMap.end()) ? it->second : "";
}

std::string ConfigManager::getOrDefault(const std::string& key, const std::string& defaultValue) const {
    std::lock_guard<std::mutex> lock(configMutex);
    auto it = configMap.find(key);
    return (it != configMap.end()) ? it->second : defaultValue;
}

void ConfigManager::set(const std::string& key, const std::string& value) {
    std::lock_guard<std::mutex> lock(configMutex);
    configMap[key] = value;
}

bool ConfigManager::hasKey(const std::string& key) const {
    std::lock_guard<std::mutex> lock(configMutex);
    return configMap.find(key) != configMap.end();
}

std::map<std::string, std::string> ConfigManager::listAll() const {
    std::lock_guard<std::mutex> lock(configMutex);
    return configMap;
}

// =============================================================================
// 타입별 설정값 조회 (편의 기능)
// =============================================================================

int ConfigManager::getInt(const std::string& key, int defaultValue) const {
    std::string value = get(key);
    if (value.empty()) {
        return defaultValue;
    }
    
    try {
        return std::stoi(value);
    } catch (const std::exception&) {
        return defaultValue;
    }
}

bool ConfigManager::getBool(const std::string& key, bool defaultValue) const {
    std::string value = get(key);
    if (value.empty()) {
        return defaultValue;
    }
    
    // true, yes, 1, on을 true로 인식
    std::transform(value.begin(), value.end(), value.begin(), ::tolower);
    return (value == "true" || value == "yes" || value == "1" || value == "on");
}

double ConfigManager::getDouble(const std::string& key, double defaultValue) const {
    std::string value = get(key);
    if (value.empty()) {
        return defaultValue;
    }
    
    try {
        return std::stod(value);
    } catch (const std::exception&) {
        return defaultValue;
    }
}

// =============================================================================
// 디버깅 도구
// =============================================================================

void ConfigManager::printConfigSearchLog() const {
    std::cout << "\n🔍 ConfigManager 경로 검색 로그:\n";
    std::cout << "================================================\n";
    
    for (const auto& log_entry : searchLog_) {
        std::cout << log_entry << "\n";
    }
    
    std::cout << "\n📄 로드된 설정 파일들:\n";
    for (const auto& file : loadedFiles_) {
        std::cout << "  " << file << "\n";
    }
    
    std::cout << "\n⚙️ 총 " << configMap.size() << "개 설정 항목 로드됨\n";
    std::cout << "================================================\n\n";
}

// =============================================================================
// 템플릿 생성 기능들 (간소화 버전)
// =============================================================================

void ConfigManager::ensureConfigFilesExist() {
    PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
        "🔍 설정 파일 존재 여부 확인 중...");
    
    try {
        // 메인 .env 파일만 확인/생성
        std::string main_env_path = configDir_ + "/.env";
        if (!std::filesystem::exists(main_env_path)) {
            PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
                "⚠️ 메인 설정 파일 없음, 기본 템플릿 생성: .env");
            createMainEnvFile();
        } else {
            PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
                "✅ 메인 설정 파일 존재: .env");
        }
        
        // 기본 추가 파일들도 생성 (실패해도 계속 진행)
        createDefaultConfigFiles();
        
    } catch (const std::exception& e) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "⚠️ 설정 파일 확인 중 오류: " + std::string(e.what()) + " (계속 진행)");
    }
}

void ConfigManager::createDefaultConfigFiles() {
    try {
        createSecretsDirectory();
        createDatabaseEnvFile();
        createRedisEnvFile();
        createTimeseriesEnvFile();
        createMessagingEnvFile();
        
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
            "✅ 기본 설정 파일들이 생성되었습니다.");
            
    } catch (const std::exception& e) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "⚠️ 추가 설정 파일 생성 실패: " + std::string(e.what()));
    }
}

void ConfigManager::createMainEnvFile() {
    std::string content = R"(# =============================================================================
# PulseOne 메인 설정 파일 (.env) - 자동 생성됨
# =============================================================================

# 환경 설정
NODE_ENV=development
LOG_LEVEL=info

# 기본 데이터베이스 설정
DATABASE_TYPE=SQLITE

# 기본 디렉토리 설정
DATA_DIR=./data

# 시스템 설정
MAX_WORKER_THREADS=4
DEFAULT_TIMEOUT_MS=5000

# 추가 설정 파일들 (선택적)
CONFIG_FILES=database.env,redis.env,timeseries.env,messaging.env
)";
    
    createFileFromTemplate(configDir_ + "/.env", content);
}

void ConfigManager::createDatabaseEnvFile() {
    std::string content = R"(# =============================================================================
# 데이터베이스 설정 (database.env) - 자동 생성됨
# =============================================================================

# 메인 데이터베이스 타입 선택
DATABASE_TYPE=SQLITE

# SQLite 설정 (기본값)
SQLITE_PATH=${DATA_DIR}/db/pulseone.db
SQLITE_BACKUP_PATH=${DATA_DIR}/backup/
SQLITE_LOGS_PATH=${DATA_DIR}/logs/

# SQLite 성능 설정
SQLITE_JOURNAL_MODE=WAL
SQLITE_SYNCHRONOUS=NORMAL
SQLITE_CACHE_SIZE=2000
SQLITE_BUSY_TIMEOUT_MS=5000
SQLITE_FOREIGN_KEYS=true

# PostgreSQL 설정 (필요시 활성화)
# POSTGRES_PRIMARY_HOST=localhost
# POSTGRES_PRIMARY_PORT=5432
# POSTGRES_PRIMARY_DB=pulseone_main
# POSTGRES_PRIMARY_USER=postgres
)";

    createFileFromTemplate(configDir_ + "/database.env", content);
}

void ConfigManager::createRedisEnvFile() {
    std::string content = R"(# =============================================================================
# Redis 설정 (redis.env) - 자동 생성됨
# =============================================================================

# Primary Redis 서버
REDIS_PRIMARY_HOST=localhost
REDIS_PRIMARY_PORT=6379
REDIS_PRIMARY_DB=0
REDIS_PRIMARY_SSL=false

# Redis 연결 설정
REDIS_CONNECTION_TIMEOUT=5000
REDIS_MAX_CONNECTIONS=20
REDIS_RETRY_ATTEMPTS=3
)";

    createFileFromTemplate(configDir_ + "/redis.env", content);
}

void ConfigManager::createTimeseriesEnvFile() {
    std::string content = R"(# =============================================================================
# 시계열 데이터베이스 설정 (timeseries.env) - 자동 생성됨
# =============================================================================

# InfluxDB 설정
INFLUX_HOST=localhost
INFLUX_PORT=8086
INFLUX_ORG=pulseone
INFLUX_BUCKET=telemetry_data
INFLUX_SSL=false

# InfluxDB 성능 설정
INFLUX_BATCH_SIZE=1000
INFLUX_FLUSH_INTERVAL_SEC=10
INFLUX_RETRY_INTERVAL_SEC=5
INFLUX_MAX_RETRIES=3
)";

    createFileFromTemplate(configDir_ + "/timeseries.env", content);
}

void ConfigManager::createMessagingEnvFile() {
    std::string content = R"(# =============================================================================
# 메시징 시스템 설정 (messaging.env) - 자동 생성됨
# =============================================================================

# RabbitMQ 설정
RABBITMQ_HOST=localhost
RABBITMQ_PORT=5672
RABBITMQ_MANAGEMENT_PORT=15672
RABBITMQ_USER=admin
RABBITMQ_VHOST=pulseone
RABBITMQ_SSL=false

# RabbitMQ 연결 설정
RABBITMQ_CONNECTION_TIMEOUT=30
RABBITMQ_HEARTBEAT_INTERVAL=60
RABBITMQ_MAX_CHANNELS=100
RABBITMQ_AUTO_RECOVERY=true
)";

    createFileFromTemplate(configDir_ + "/messaging.env", content);
}

void ConfigManager::createSecretsDirectory() {
    std::string secrets_dir = configDir_ + "/secrets";
    
    try {
        if (std::filesystem::exists(secrets_dir)) {
            return;
        }
        
        std::filesystem::create_directories(secrets_dir);
        
        // README 파일 생성
        std::string readme_content = R"(# Secrets Directory

이 디렉토리는 암호화된 비밀번호 파일들을 저장합니다.

## 생성해야 할 파일들 (예시)
- postgres_primary.key
- redis_primary.key  
- influx_token.key
- rabbitmq.key
)";

        createFileFromTemplate(secrets_dir + "/README.md", readme_content);
        createFileFromTemplate(secrets_dir + "/.gitignore", "*\n!README.md\n!.gitignore\n");
        
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
            "✅ Secrets 디렉토리 생성: " + secrets_dir);
            
    } catch (const std::exception& e) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "⚠️ Secrets 디렉토리 생성 실패: " + std::string(e.what()));
    }
}

bool ConfigManager::createFileFromTemplate(const std::string& filepath, const std::string& content) {
    try {
        // 파일이 이미 존재하면 생성하지 않음
        if (std::filesystem::exists(filepath)) {
            return true;
        }
        
        std::ofstream file(filepath);
        if (!file.is_open()) {
            return false;
        }
        
        file << content;
        file.close();
        
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::INFO, 
            "✅ 설정 파일 생성: " + std::filesystem::path(filepath).filename().string());
        
        return true;
        
    } catch (const std::exception& e) {
        PulseOne::LogManager::getInstance().log("config", PulseOne::LogLevel::WARN, 
            "⚠️ 파일 생성 중 예외: " + std::string(e.what()));
        return false;
    }
}

// =============================================================================
// 데이터 경로 관련
// =============================================================================

std::string ConfigManager::findDataDirectory() {
    // 1. 환경변수 최우선 확인
    const char* env_data = std::getenv("PULSEONE_DATA_DIR");
    if (env_data && strlen(env_data) > 0) {
        return std::string(env_data);
    }
    
    // 2. 설정파일에서 확인
    std::string config_data = get("DATA_DIR");
    if (!config_data.empty()) {
        return expandVariables(config_data);
    }
    
    // 3. 기본 경로 사용
    return "./data";
}

void ConfigManager::ensureDataDirectories() {
    if (dataDir_.empty()) {
        return;
    }
    
    std::vector<std::string> dirs = {"db", "logs", "backup", "temp"};
    
    for (const auto& dir : dirs) {
        try {
            std::string full_path = dataDir_ + "/" + dir;
            std::filesystem::create_directories(full_path);
        } catch (const std::exception&) {
            // 실패해도 계속 진행
        }
    }
}

// =============================================================================
// 편의 메서드들
// =============================================================================

std::string ConfigManager::getDataDirectory() const {
    return dataDir_.empty() ? "./data" : dataDir_;
}

std::string ConfigManager::getSQLiteDbPath() const {
    std::string sqlite_path = get("SQLITE_PATH");
    if (!sqlite_path.empty()) {
        return expandVariables(sqlite_path);
    }
    return getDataDirectory() + "/db/pulseone.db";
}

std::string ConfigManager::getBackupDirectory() const {
    std::string backup_path = get("SQLITE_BACKUP_PATH");
    if (!backup_path.empty()) {
        return expandVariables(backup_path);
    }
    return getDataDirectory() + "/backup";
}