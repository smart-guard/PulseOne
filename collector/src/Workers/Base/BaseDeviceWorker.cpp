/**
 * @file BaseDeviceWorker.cpp
 * @brief BaseDeviceWorker ÌÅ¥ÎûòÏä§ Íµ¨ÌòÑ (GitHub Íµ¨Ï°∞ ÎßûÏ∂§)
 * @author PulseOne Development Team
 * @date 2025-01-20
 * @version 2.0.0
 */

#include "Workers/Base/BaseDeviceWorker.h"
#include "Utils/LogManager.h"
#include "Common/Enums.h"
#include <sstream>
#include <iomanip>
#include <thread>

using namespace std::chrono;
using LogLevel = PulseOne::Enums::LogLevel;

namespace PulseOne {
namespace Workers {

// =============================================================================
// ReconnectionSettings Íµ¨ÌòÑ
// =============================================================================

std::string ReconnectionSettings::ToJson() const {
    std::stringstream ss;
    ss << "{\n";
    ss << "  \"auto_reconnect_enabled\": " << (auto_reconnect_enabled ? "true" : "false") << ",\n";
    ss << "  \"retry_interval_ms\": " << retry_interval_ms << ",\n";
    ss << "  \"max_retries_per_cycle\": " << max_retries_per_cycle << ",\n";
    ss << "  \"wait_time_after_max_retries_ms\": " << wait_time_after_max_retries_ms << ",\n";
    ss << "  \"keep_alive_enabled\": " << (keep_alive_enabled ? "true" : "false") << ",\n";
    ss << "  \"keep_alive_interval_seconds\": " << keep_alive_interval_seconds << ",\n";
    ss << "  \"connection_timeout_seconds\": " << connection_timeout_seconds << "\n";
    ss << "}";
    return ss.str();
}

bool ReconnectionSettings::FromJson(const std::string& json_str) {
    // Í∞ÑÎã®Ìïú JSON ÌååÏã± (Ïã§Ï†úÎ°úÎäî JSON ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏÇ¨Ïö© Í∂åÏû•)
    try {
        // auto_reconnect_enabled ÌååÏã±
        size_t pos = json_str.find("\"auto_reconnect_enabled\":");
        if (pos != std::string::npos) {
            size_t value_start = json_str.find(":", pos) + 1;
            size_t value_end = json_str.find_first_of(",}", value_start);
            std::string value = json_str.substr(value_start, value_end - value_start);
            value.erase(0, value.find_first_not_of(" \t"));
            value.erase(value.find_last_not_of(" \t") + 1);
            auto_reconnect_enabled = (value == "true");
        }
        
        // retry_interval_ms ÌååÏã±
        pos = json_str.find("\"retry_interval_ms\":");
        if (pos != std::string::npos) {
            size_t value_start = json_str.find(":", pos) + 1;
            size_t value_end = json_str.find_first_of(",}", value_start);
            std::string value = json_str.substr(value_start, value_end - value_start);
            value.erase(0, value.find_first_not_of(" \t"));
            value.erase(value.find_last_not_of(" \t") + 1);
            retry_interval_ms = std::stoi(value);
        }
        
        // max_retries_per_cycle ÌååÏã±
        pos = json_str.find("\"max_retries_per_cycle\":");
        if (pos != std::string::npos) {
            size_t value_start = json_str.find(":", pos) + 1;
            size_t value_end = json_str.find_first_of(",}", value_start);
            std::string value = json_str.substr(value_start, value_end - value_start);
            value.erase(0, value.find_first_not_of(" \t"));
            value.erase(value.find_last_not_of(" \t") + 1);
            max_retries_per_cycle = std::stoi(value);
        }
        
        // wait_time_after_max_retries_ms ÌååÏã±
        pos = json_str.find("\"wait_time_after_max_retries_ms\":");
        if (pos != std::string::npos) {
            size_t value_start = json_str.find(":", pos) + 1;
            size_t value_end = json_str.find_first_of(",}", value_start);
            std::string value = json_str.substr(value_start, value_end - value_start);
            value.erase(0, value.find_first_not_of(" \t"));
            value.erase(value.find_last_not_of(" \t") + 1);
            wait_time_after_max_retries_ms = std::stoi(value);
        }
        
        // keep_alive_enabled ÌååÏã±
        pos = json_str.find("\"keep_alive_enabled\":");
        if (pos != std::string::npos) {
            size_t value_start = json_str.find(":", pos) + 1;
            size_t value_end = json_str.find_first_of(",}", value_start);
            std::string value = json_str.substr(value_start, value_end - value_start);
            value.erase(0, value.find_first_not_of(" \t"));
            value.erase(value.find_last_not_of(" \t") + 1);
            keep_alive_enabled = (value == "true");
        }
        
        // keep_alive_interval_seconds ÌååÏã±
        pos = json_str.find("\"keep_alive_interval_seconds\":");
        if (pos != std::string::npos) {
            size_t value_start = json_str.find(":", pos) + 1;
            size_t value_end = json_str.find_first_of(",}", value_start);
            std::string value = json_str.substr(value_start, value_end - value_start);
            value.erase(0, value.find_first_not_of(" \t"));
            value.erase(value.find_last_not_of(" \t") + 1);
            keep_alive_interval_seconds = std::stoi(value);
        }
        
        // connection_timeout_seconds ÌååÏã±
        pos = json_str.find("\"connection_timeout_seconds\":");
        if (pos != std::string::npos) {
            size_t value_start = json_str.find(":", pos) + 1;
            size_t value_end = json_str.find_first_of(",}", value_start);
            std::string value = json_str.substr(value_start, value_end - value_start);
            value.erase(0, value.find_first_not_of(" \t"));
            value.erase(value.find_last_not_of(" \t") + 1);
            connection_timeout_seconds = std::stoi(value);
        }
        
        return true;
    } catch (const std::exception&) {
        return false;
    }
}

// =============================================================================
// BaseDeviceWorker ÏÉùÏÑ±Ïûê Î∞è ÏÜåÎ©∏Ïûê
// =============================================================================

BaseDeviceWorker::BaseDeviceWorker(const PulseOne::DeviceInfo& device_info)
    : device_info_(device_info) {
    
    // üî• Worker ID ÏÉùÏÑ± (Í∏∞Ï°¥ Î∞©Ïãù ÏÇ¨Ïö©)
    std::stringstream ss;
    ss << device_info_.protocol_type << "_" << device_info_.id;
    worker_id_ = ss.str();
    
    LogMessage(LogLevel::INFO, "BaseDeviceWorker ÏÉùÏÑ±Îê® (Worker ID: " + worker_id_ + ")");

    // ÌÜµÍ≥Ñ Ï¥àÍ∏∞Ìôî
    reconnection_stats_.first_connection_time = system_clock::now();
    wait_start_time_ = system_clock::now();
    last_keep_alive_time_ = system_clock::now();
    
    LogMessage(LogLevel::INFO, "BaseDeviceWorker created for device: " + device_info_.name);
    
    // Ïû¨Ïó∞Í≤∞ Í¥ÄÎ¶¨ Ïä§Î†àÎìú ÏãúÏûë
    thread_running_ = true;
    reconnection_thread_ = std::make_unique<std::thread>(&BaseDeviceWorker::ReconnectionThreadMain, this);
}

BaseDeviceWorker::~BaseDeviceWorker() {
    // Ïû¨Ïó∞Í≤∞ Ïä§Î†àÎìú Ï†ïÎ¶¨
    thread_running_ = false;
    if (reconnection_thread_ && reconnection_thread_->joinable()) {
        reconnection_thread_->join();
    }
    
    LogMessage(LogLevel::INFO, "BaseDeviceWorker destroyed for device: " + device_info_.name);
}

// =============================================================================
// Í≥µÌÜµ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Íµ¨ÌòÑ
// =============================================================================

bool BaseDeviceWorker::AddDataPoint(const PulseOne::DataPoint& point) {
    std::lock_guard<std::mutex> lock(data_points_mutex_);
    
    // Ï§ëÎ≥µ ÌôïÏù∏ (GitHub Íµ¨Ï°∞: point_id -> id)
    for (const auto& existing_point : data_points_) {
        if (existing_point.id == point.id) {
            LogMessage(LogLevel::WARN, "Data point already exists: " + point.name);
            return false;
        }
    }
    
    data_points_.push_back(point);
    LogMessage(LogLevel::INFO, "Data point added: " + point.name);
    return true;
}

std::vector<PulseOne::DataPoint> BaseDeviceWorker::GetDataPoints() const {
    std::lock_guard<std::mutex> lock(data_points_mutex_);
    return data_points_;
}

// =============================================================================
// Ïû¨Ïó∞Í≤∞ Í¥ÄÎ¶¨ - UpdateReconnectionSettings Íµ¨ÌòÑ Ï∂îÍ∞Ä
// =============================================================================

bool BaseDeviceWorker::UpdateReconnectionSettings(const ReconnectionSettings& settings) {
    std::lock_guard<std::mutex> lock(settings_mutex_);
    reconnection_settings_ = settings;
    LogMessage(LogLevel::INFO, "Reconnection settings updated");
    return true;
}

ReconnectionSettings BaseDeviceWorker::GetReconnectionSettings() const {
    std::lock_guard<std::mutex> lock(settings_mutex_);
    return reconnection_settings_;
}

std::future<bool> BaseDeviceWorker::ForceReconnect() {
    auto promise = std::make_shared<std::promise<bool>>();
    auto future = promise->get_future();
    
    std::thread([this, promise]() {
        try {
            LogMessage(LogLevel::INFO, "Force reconnect requested");
            
            // ÌòÑÏû¨ Ïó∞Í≤∞ Í∞ïÏ†ú Ï¢ÖÎ£å
            if (is_connected_.load()) {
                CloseConnection();
                SetConnectionState(false);
                std::this_thread::sleep_for(std::chrono::milliseconds(500));
            }
            
            // Ïû¨Ïó∞Í≤∞ ÏÉÅÌÉú Î¶¨ÏÖã
            ResetReconnectionState();
            
            // Ï¶âÏãú Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
            bool success = AttemptReconnection();
            
            LogMessage(LogLevel::INFO, "Force reconnect " + std::string(success ? "successful" : "failed"));
            promise->set_value(success);
            
        } catch (const std::exception& e) {
            LogMessage(LogLevel::ERROR, "Exception in force reconnect: " + std::string(e.what()));
            promise->set_value(false);
        }
    }).detach();
    
    return future;
}

std::string BaseDeviceWorker::GetReconnectionStats() const {
    std::stringstream ss;
    ss << "{\n";
    ss << "  \"connection_stats\": {\n";
    ss << "    \"total_connections\": " << reconnection_stats_.total_connections.load() << ",\n";
    ss << "    \"successful_connections\": " << reconnection_stats_.successful_connections.load() << ",\n";
    ss << "    \"failed_connections\": " << reconnection_stats_.failed_connections.load() << ",\n";
    ss << "    \"reconnection_cycles\": " << reconnection_stats_.reconnection_cycles.load() << ",\n";
    ss << "    \"wait_cycles\": " << reconnection_stats_.wait_cycles.load() << ",\n";
    ss << "    \"keep_alive_sent\": " << reconnection_stats_.keep_alive_sent.load() << ",\n";
    ss << "    \"keep_alive_failed\": " << reconnection_stats_.keep_alive_failed.load() << ",\n";
    ss << "    \"avg_connection_duration_seconds\": " << reconnection_stats_.avg_connection_duration_seconds.load() << "\n";
    ss << "  },\n";
    ss << "  \"current_state\": {\n";
    ss << "    \"connected\": " << (is_connected_.load() ? "true" : "false") << ",\n";
    ss << "    \"current_retry_count\": " << current_retry_count_.load() << ",\n";
    ss << "    \"in_wait_cycle\": " << (in_wait_cycle_.load() ? "true" : "false") << ",\n";
    ss << "    \"worker_state\": \"" << WorkerStateToString(current_state_.load()) << "\"\n";
    ss << "  }\n";
    ss << "}";
    return ss.str();
}

void BaseDeviceWorker::ResetReconnectionState() {
    current_retry_count_ = 0;
    in_wait_cycle_ = false;
    wait_start_time_ = system_clock::now();
    
    LogMessage(LogLevel::INFO, "Reconnection state reset");
}

// =============================================================================
// ÏÉÅÌÉú Í¥ÄÎ¶¨
// =============================================================================

std::string BaseDeviceWorker::GetStatusJson() const {
    std::stringstream ss;
    ss << "{\n";
    ss << "  \"device_id\": \"" << device_info_.id << "\",\n";
    ss << "  \"device_name\": \"" << device_info_.name << "\",\n";
    ss << "  \"worker_id\": \"" << worker_id_ << "\",\n";
    ss << "  \"protocol_type\": \"" << device_info_.protocol_type << "\",\n";
    ss << "  \"endpoint\": \"" << device_info_.endpoint << "\",\n";
    ss << "  \"state\": \"" << WorkerStateToString(current_state_.load()) << "\",\n";
    ss << "  \"connected\": " << (is_connected_.load() ? "true" : "false") << ",\n";
    ss << "  \"data_points_count\": " << data_points_.size() << "\n";
    ss << "}";
    return ss.str();
}

// =============================================================================
// Î≥¥Ìò∏Îêú Î©îÏÑúÎìúÎì§
// =============================================================================

void BaseDeviceWorker::ChangeState(WorkerState new_state) {
    WorkerState old_state = current_state_.exchange(new_state);
    
    if (old_state != new_state) {
        LogMessage(LogLevel::INFO, 
                  "ÏÉÅÌÉú Î≥ÄÍ≤Ω: " + WorkerStateToString(old_state) + " ‚Üí " + WorkerStateToString(new_state));
        
        // üî• ÌååÏù¥ÌîÑÎùºÏù∏ ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÍ≥† Î°úÍπÖÎßå ÏàòÌñâ
        LogMessage(LogLevel::DEBUG_LEVEL, "Worker state changed to " + WorkerStateToString(new_state));
    }
}

void BaseDeviceWorker::SetConnectionState(bool connected) {
    bool old_connected = is_connected_.exchange(connected);
    
    if (old_connected != connected) {
        LogMessage(LogLevel::INFO, connected ? "ÎîîÎ∞îÏù¥Ïä§ Ïó∞Í≤∞Îê®" : "ÎîîÎ∞îÏù¥Ïä§ Ïó∞Í≤∞ Ìï¥Ï†úÎê®");
        
        // üî• ÌååÏù¥ÌîÑÎùºÏù∏ ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÍ≥† Î°úÍπÖÎßå ÏàòÌñâ
        LogMessage(LogLevel::DEBUG_LEVEL, connected ? "Connected" : "Disconnected");
        
        // ÏÉÅÌÉú Î≥ÄÍ≤Ω Î°úÏßÅ
        if (connected && current_state_.load() == WorkerState::RECONNECTING) {
            ChangeState(WorkerState::RUNNING);
        } else if (!connected && current_state_.load() == WorkerState::RUNNING) {
            ChangeState(WorkerState::DEVICE_OFFLINE);
        }
    }
}

void BaseDeviceWorker::HandleConnectionError(const std::string& error_message) {
    LogMessage(LogLevel::ERROR, "Ïó∞Í≤∞ ÏóêÎü¨: " + error_message);
    
    SetConnectionState(false);
    
    // üî• ÌååÏù¥ÌîÑÎùºÏù∏ ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÍ≥† Î°úÍπÖÎßå ÏàòÌñâ
    LogMessage(LogLevel::ERROR, "Connection error: " + error_message);
    
    // Ïû¨Ïó∞Í≤∞ ÏÉÅÌÉúÎ°ú Î≥ÄÍ≤Ω
    if (current_state_.load() == WorkerState::RUNNING) {
        ChangeState(WorkerState::RECONNECTING);
    }
}

// =============================================================================
// ÎÇ¥Î∂Ä Î©îÏÑúÎìúÎì§
// =============================================================================

void BaseDeviceWorker::ReconnectionThreadMain() {
    LogMessage(LogLevel::INFO, "Ïû¨Ïó∞Í≤∞ Í¥ÄÎ¶¨ Ïä§Î†àÎìú ÏãúÏûëÎê®");
    
    while (thread_running_.load()) {
        try {
            WorkerState current_state = current_state_.load();
            
            // Ïã§Ìñâ Ï§ëÏù¥Í≥† Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥ÏßÑ Í≤ΩÏö∞Îßå Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
            if ((current_state == WorkerState::RUNNING || current_state == WorkerState::RECONNECTING) &&
                !is_connected_.load()) {
                
                LogMessage(LogLevel::DEBUG_LEVEL, "Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ");
                
                if (AttemptReconnection()) {
                    LogMessage(LogLevel::INFO, "Ïû¨Ïó∞Í≤∞ ÏÑ±Í≥µ");
                    if (current_state == WorkerState::RECONNECTING) {
                        ChangeState(WorkerState::RUNNING);
                    }
                } else {
                    LogMessage(LogLevel::DEBUG_LEVEL, "Ïû¨Ïó∞Í≤∞ Ïã§Ìå®, 5Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ");
                }
            }
            
            // 5Ï¥àÎßàÎã§ Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
            std::this_thread::sleep_for(std::chrono::seconds(5));
            
        } catch (const std::exception& e) {
            LogMessage(LogLevel::ERROR, "Ïû¨Ïó∞Í≤∞ Ïä§Î†àÎìú ÏòàÏô∏: " + std::string(e.what()));
            std::this_thread::sleep_for(std::chrono::seconds(10));
        }
    }
    
    LogMessage(LogLevel::INFO, "Ïû¨Ïó∞Í≤∞ Í¥ÄÎ¶¨ Ïä§Î†àÎìú Ï¢ÖÎ£åÎê®");
}

bool BaseDeviceWorker::AttemptReconnection() {
    try {
        LogMessage(LogLevel::DEBUG_LEVEL, "Ïó∞Í≤∞ ÏàòÎ¶Ω ÏãúÎèÑ");
        
        if (EstablishConnection()) {
            SetConnectionState(true);
            return true;
        } else {
            return false;
        }
        
    } catch (const std::exception& e) {
        LogMessage(LogLevel::ERROR, "Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ Ï§ë ÏòàÏô∏: " + std::string(e.what()));
        return false;
    }
}

void BaseDeviceWorker::HandleKeepAlive() {
    if (!reconnection_settings_.keep_alive_enabled) {
        return;
    }
    
    auto now = system_clock::now();
    auto time_since_last_keepalive = duration_cast<seconds>(now - last_keep_alive_time_).count();
    
    if (time_since_last_keepalive >= reconnection_settings_.keep_alive_interval_seconds) {
        try {
            // ÌîÑÎ°úÌÜ†ÏΩúÎ≥Ñ Keep-alive Ï†ÑÏÜ° (Í∏∞Î≥∏ Íµ¨ÌòÑÏùÄ Ïó∞Í≤∞ ÏÉÅÌÉúÎßå ÌôïÏù∏)
            bool keepalive_success = SendKeepAlive();
            
            if (keepalive_success) {
                // Ï∂îÍ∞ÄÎ°ú Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
                if (!CheckConnection()) {
                    LogMessage(LogLevel::WARN, "Keep-alive sent but connection check failed");
                    HandleConnectionError("Keep-alive connection check failed");
                    reconnection_stats_.keep_alive_failed.fetch_add(1);
                } else {
                    reconnection_stats_.keep_alive_sent.fetch_add(1);
                    LogMessage(LogLevel::DEBUG_LEVEL, "Keep-alive successful");
                }
            } else {
                LogMessage(LogLevel::WARN, "Keep-alive failed");
                HandleConnectionError("Keep-alive send failed");
                reconnection_stats_.keep_alive_failed.fetch_add(1);
            }
            
            last_keep_alive_time_ = now;
            
        } catch (const std::exception& e) {
            LogMessage(LogLevel::ERROR, "Keep-alive exception: " + std::string(e.what()));
            HandleConnectionError("Keep-alive exception: " + std::string(e.what()));
            reconnection_stats_.keep_alive_failed.fetch_add(1);
        }
    }
}

void BaseDeviceWorker::InitializeRedisChannels() {
    status_channel_ = "device_status:" + device_info_.id;
    reconnection_channel_ = "device_reconnection:" + device_info_.id;
}

void BaseDeviceWorker::UpdateReconnectionStats(bool connection_successful) {
    if (connection_successful) {
        reconnection_stats_.successful_connections.fetch_add(1);
        reconnection_stats_.last_successful_connection = system_clock::now();
        
        // ÌèâÍ∑† Ïó∞Í≤∞ ÏßÄÏÜç ÏãúÍ∞Ñ Í≥ÑÏÇ∞ (Í∞ÑÎã®Ìïú Íµ¨ÌòÑ)
        static auto last_connection_start = system_clock::now();
        last_connection_start = system_clock::now();
        
    } else {
        reconnection_stats_.failed_connections.fetch_add(1);
        reconnection_stats_.last_failure_time = system_clock::now();
        
        // Ïó∞Í≤∞ ÏßÄÏÜç ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ (Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥Ïßà Îïå)
        static auto last_connection_start = system_clock::now();
        auto duration = duration_cast<seconds>(system_clock::now() - last_connection_start).count();
        
        if (duration > 0) {
            double current_avg = reconnection_stats_.avg_connection_duration_seconds.load();
            double new_avg = (current_avg + duration) / 2.0; // Í∞ÑÎã®Ìïú Ïù¥Îèô ÌèâÍ∑†
            reconnection_stats_.avg_connection_duration_seconds.store(new_avg);
        }
    }
}

std::string BaseDeviceWorker::WorkerStateToString(WorkerState state) const{
    switch (state) {
        case WorkerState::STOPPED: return "STOPPED";
        case WorkerState::STARTING: return "STARTING";
        case WorkerState::RUNNING: return "RUNNING";
        case WorkerState::PAUSED: return "PAUSED";
        case WorkerState::STOPPING: return "STOPPING";
        case WorkerState::ERROR: return "ERROR";
        case WorkerState::MAINTENANCE: return "MAINTENANCE";
        case WorkerState::SIMULATION: return "SIMULATION";
        case WorkerState::CALIBRATION: return "CALIBRATION";
        case WorkerState::COMMISSIONING: return "COMMISSIONING";
        case WorkerState::DEVICE_OFFLINE: return "DEVICE_OFFLINE";
        case WorkerState::COMMUNICATION_ERROR: return "COMMUNICATION_ERROR";
        case WorkerState::DATA_INVALID: return "DATA_INVALID";
        case WorkerState::SENSOR_FAULT: return "SENSOR_FAULT";
        case WorkerState::MANUAL_OVERRIDE: return "MANUAL_OVERRIDE";
        case WorkerState::EMERGENCY_STOP: return "EMERGENCY_STOP";
        case WorkerState::BYPASS_MODE: return "BYPASS_MODE";
        case WorkerState::DIAGNOSTIC_MODE: return "DIAGNOSTIC_MODE";
        case WorkerState::RECONNECTING: return "RECONNECTING";
        case WorkerState::WAITING_RETRY: return "WAITING_RETRY";
        case WorkerState::MAX_RETRIES_EXCEEDED: return "MAX_RETRIES_EXCEEDED";
        default: return "UNKNOWN";
    }
}

/**
 * @brief ÌôúÏÑ± ÏÉÅÌÉúÏù∏ÏßÄ ÌôïÏù∏
 * @param state ÏõåÏª§ ÏÉÅÌÉú
 * @return ÌôúÏÑ± ÏÉÅÌÉúÏù¥Î©¥ true
 */
bool BaseDeviceWorker::IsActiveState(WorkerState state) {
    return state == WorkerState::RUNNING ||
           state == WorkerState::SIMULATION ||
           state == WorkerState::CALIBRATION ||
           state == WorkerState::COMMISSIONING ||
           state == WorkerState::MAINTENANCE ||
           state == WorkerState::DIAGNOSTIC_MODE;
}

/**
 * @brief ÏóêÎü¨ ÏÉÅÌÉúÏù∏ÏßÄ ÌôïÏù∏
 * @param state ÏõåÏª§ ÏÉÅÌÉú
 * @return ÏóêÎü¨ ÏÉÅÌÉúÏù¥Î©¥ true
 */
bool BaseDeviceWorker::IsErrorState(WorkerState state) {
    return state == WorkerState::ERROR ||
           state == WorkerState::DEVICE_OFFLINE ||
           state == WorkerState::COMMUNICATION_ERROR ||
           state == WorkerState::DATA_INVALID ||
           state == WorkerState::SENSOR_FAULT ||
           state == WorkerState::EMERGENCY_STOP ||
           state == WorkerState::MAX_RETRIES_EXCEEDED;
}

// =============================================================================
// üî• ÌååÏù¥ÌîÑÎùºÏù∏ Ï†ÑÏÜ° Î©îÏÑúÎìú (ÏûÑÏãúÎ°ú ÎπÑÌôúÏÑ±Ìôî)
// =============================================================================

bool BaseDeviceWorker::SendDataToPipeline(const std::vector<PulseOne::TimestampedValue>& values, 
                                         uint32_t priority) {
    if (values.empty()) {
        LogMessage(LogLevel::DEBUG_LEVEL, "Ï†ÑÏÜ°Ìï† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏùå");
        return false;
    }
    
    // üî• ÏûÑÏãúÎ°ú ÌååÏù¥ÌîÑÎùºÏù∏ Í∏∞Îä• ÎπÑÌôúÏÑ±Ìôî (Î°úÍπÖÎßå ÏàòÌñâ)
    std::stringstream log_msg;
    log_msg << values.size() << "Í∞ú Îç∞Ïù¥ÌÑ∞ Ìè¨Ïù∏Ìä∏ ÏàòÏã† (Ïö∞ÏÑ†ÏàúÏúÑ: " << priority << ")";
    LogMessage(LogLevel::DEBUG_LEVEL, log_msg.str());
    
    // TODO: Ïã§Ï†ú ÌååÏù¥ÌîÑÎùºÏù∏ Íµ¨ÌòÑ ÌõÑ ÌôúÏÑ±Ìôî
    return true;
}

// =============================================================================
// üî• ÎùºÏù¥ÌîÑÏÇ¨Ïù¥ÌÅ¥ Í¥ÄÎ¶¨
// =============================================================================

std::future<bool> BaseDeviceWorker::Pause() {
    return std::async(std::launch::async, [this]() -> bool {
        if (current_state_.load() == WorkerState::RUNNING) {
            ChangeState(WorkerState::PAUSED);
            LogMessage(LogLevel::INFO, "Worker ÏùºÏãúÏ†ïÏßÄÎê®");
            return true;
        } else {
            LogMessage(LogLevel::WARN, "ÌòÑÏû¨ ÏÉÅÌÉúÏóêÏÑú ÏùºÏãúÏ†ïÏßÄÌï† Ïàò ÏóÜÏùå");
            return false;
        }
    });
}

std::future<bool> BaseDeviceWorker::Resume() {
    return std::async(std::launch::async, [this]() -> bool {
        if (current_state_.load() == WorkerState::PAUSED) {
            ChangeState(WorkerState::RUNNING);
            LogMessage(LogLevel::INFO, "Worker Ïû¨Í∞úÎê®");
            return true;
        } else {
            LogMessage(LogLevel::WARN, "ÌòÑÏû¨ ÏÉÅÌÉúÏóêÏÑú Ïû¨Í∞úÌï† Ïàò ÏóÜÏùå");
            return false;
        }
    });
}

void BaseDeviceWorker::LogMessage(LogLevel level, const std::string& message) const {
    std::string prefix = "[Worker:" + device_info_.name + "] ";
    LogManager::getInstance().log("worker", level, prefix + message);
}

} // namespace Workers
} // namespace PulseOne