// =============================================================================
// collector/src/Database/RepositoryFactory.cpp
// PulseOne Repository Ìå©ÌÜ†Î¶¨ Íµ¨ÌòÑ - ÏôÑÏ†ÑÌïú Íµ¨ÌòÑ (CurrentValueRepository Ï∂îÍ∞Ä)
// =============================================================================

#include "Database/RepositoryFactory.h"
#include <stdexcept>

namespace PulseOne {
namespace Database {

// =============================================================================
// Ïã±Í∏ÄÌÜ§ Íµ¨ÌòÑ
// =============================================================================

RepositoryFactory::RepositoryFactory()
    : db_manager_(DatabaseManager::getInstance())
    , config_manager_(ConfigManager::getInstance())
    , logger_(PulseOne::LogManager::getInstance())
    , initialized_(false)
    , global_cache_enabled_(true)
    , cache_ttl_seconds_(300)  // 5Î∂Ñ Í∏∞Î≥∏Í∞í
    , max_cache_size_(1000)
    , transaction_active_(false)
    , creation_count_(0)
    , error_count_(0)
    , transaction_count_(0) {
    
    logger_.Info("üè≠ RepositoryFactory created");
}

RepositoryFactory::~RepositoryFactory() {
    shutdown();
    logger_.Info("üè≠ RepositoryFactory destroyed");
}

RepositoryFactory& RepositoryFactory::getInstance() {
    static RepositoryFactory instance;
    return instance;
}

// =============================================================================
// Ï¥àÍ∏∞Ìôî Î∞è Ï¢ÖÎ£å
// =============================================================================

bool RepositoryFactory::initialize() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    if (initialized_) {
        logger_.Warn("RepositoryFactory already initialized");
        return true;
    }
    
    try {
        logger_.Info("üîß RepositoryFactory initializing...");
        
        // 1. DatabaseManager Ï¥àÍ∏∞Ìôî ÌôïÏù∏
        if (!db_manager_.isPostgresConnected() && !db_manager_.isSQLiteConnected()) {
            logger_.Error("DatabaseManager not connected - attempting initialization");
            if (!db_manager_.initialize()) {
                logger_.Error("Failed to initialize DatabaseManager");
                error_count_++;
                return false;
            }
        }
        
        // 2. Repository Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
        if (!createRepositoryInstances()) {
            logger_.Error("Failed to create repository instances");
            error_count_++;
            return false;
        }
        
        // 3. ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ
        if (!injectDependencies()) {
            logger_.Error("Failed to inject dependencies");
            error_count_++;
            return false;
        }
        
        // 4. RepositoryÎ≥Ñ ÏÑ§Ï†ï Ï†ÅÏö©
        applyRepositoryConfigurations();
        
        initialized_ = true;
        logger_.Info("‚úÖ RepositoryFactory initialized successfully");
        
        return true;
        
    } catch (const std::exception& e) {
        logger_.Error("RepositoryFactory::initialize failed: " + std::string(e.what()));
        error_count_++;
        return false;
    }
}

void RepositoryFactory::shutdown() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    if (!initialized_) {
        return;
    }
    
    try {
        logger_.Info("üîß RepositoryFactory shutting down...");
        
        // ÌôúÏÑ± Ìä∏ÎûúÏû≠ÏÖòÏù¥ ÏûàÏúºÎ©¥ Î°§Î∞±
        if (transaction_active_) {
            logger_.Warn("Active transaction found during shutdown - rolling back");
            rollbackGlobalTransaction();
        }
        
        // Î™®Îì† Ï∫êÏãú ÌÅ¥Î¶¨Ïñ¥
        clearAllCaches();
        
        // Repository Ïù∏Ïä§ÌÑ¥Ïä§ Ìï¥Ï†ú
        device_repository_.reset();
        data_point_repository_.reset();
        user_repository_.reset();
        tenant_repository_.reset();
        alarm_config_repository_.reset();
        site_repository_.reset();
        virtual_point_repository_.reset();
        current_value_repository_.reset();  // üÜï Ï∂îÍ∞Ä
        
        initialized_ = false;
        logger_.Info("‚úÖ RepositoryFactory shutdown completed");
        
    } catch (const std::exception& e) {
        logger_.Error("RepositoryFactory::shutdown failed: " + std::string(e.what()));
        error_count_++;
    }
}

// =============================================================================
// Repository Ïù∏Ïä§ÌÑ¥Ïä§ Ï°∞Ìöå (ÌÉÄÏûÖ Î≥ÑÏπ≠ ÏÇ¨Ïö©)
// =============================================================================

DeviceRepository& RepositoryFactory::getDeviceRepository() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    if (!initialized_) {
        throw std::runtime_error("RepositoryFactory not initialized");
    }
    
    if (!device_repository_) {
        throw std::runtime_error("DeviceRepository not created");
    }
    
    creation_count_++;
    return *device_repository_;
}

DataPointRepository& RepositoryFactory::getDataPointRepository() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    if (!initialized_) {
        throw std::runtime_error("RepositoryFactory not initialized");
    }
    
    if (!data_point_repository_) {
        throw std::runtime_error("DataPointRepository not created");
    }
    
    creation_count_++;
    return *data_point_repository_;
}

UserRepository& RepositoryFactory::getUserRepository() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    if (!initialized_) {
        throw std::runtime_error("RepositoryFactory not initialized");
    }
    
    if (!user_repository_) {
        throw std::runtime_error("UserRepository not created");
    }
    
    creation_count_++;
    return *user_repository_;
}

TenantRepository& RepositoryFactory::getTenantRepository() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    if (!initialized_) {
        throw std::runtime_error("RepositoryFactory not initialized");
    }
    
    if (!tenant_repository_) {
        throw std::runtime_error("TenantRepository not created");
    }
    
    creation_count_++;
    return *tenant_repository_;
}

AlarmConfigRepository& RepositoryFactory::getAlarmConfigRepository() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    if (!initialized_) {
        throw std::runtime_error("RepositoryFactory not initialized");
    }
    
    if (!alarm_config_repository_) {
        throw std::runtime_error("AlarmConfigRepository not created");
    }
    
    creation_count_++;
    return *alarm_config_repository_;
}

SiteRepository& RepositoryFactory::getSiteRepository() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    if (!initialized_) {
        throw std::runtime_error("RepositoryFactory not initialized");
    }
    
    if (!site_repository_) {
        throw std::runtime_error("SiteRepository not created");
    }
    
    creation_count_++;
    return *site_repository_;
}

VirtualPointRepository& RepositoryFactory::getVirtualPointRepository() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    if (!initialized_) {
        throw std::runtime_error("RepositoryFactory not initialized");
    }
    
    if (!virtual_point_repository_) {
        throw std::runtime_error("VirtualPointRepository not created");
    }
    
    creation_count_++;
    return *virtual_point_repository_;
}

// üÜï CurrentValueRepository Ïù∏Ïä§ÌÑ¥Ïä§ Ï°∞Ìöå Î©îÏÑúÎìú Ï∂îÍ∞Ä
CurrentValueRepository& RepositoryFactory::getCurrentValueRepository() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    if (!initialized_) {
        throw std::runtime_error("RepositoryFactory not initialized");
    }
    
    if (!current_value_repository_) {
        throw std::runtime_error("CurrentValueRepository not created");
    }
    
    creation_count_++;
    return *current_value_repository_;
}

// =============================================================================
// Í∏ÄÎ°úÎ≤å Ìä∏ÎûúÏû≠ÏÖò Í¥ÄÎ¶¨
// =============================================================================

bool RepositoryFactory::beginGlobalTransaction() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    if (!initialized_) {
        logger_.Error("RepositoryFactory not initialized for transaction");
        return false;
    }
    
    if (transaction_active_) {
        logger_.Warn("Global transaction already active");
        return true;
    }
    
    try {
        // PostgreSQL/SQLite Íµ¨Î∂ÑÌï¥ÏÑú Ìä∏ÎûúÏû≠ÏÖò ÏãúÏûë
        std::string db_type = config_manager_.getOrDefault("DATABASE_TYPE", "SQLITE");
        
        bool success = false;
        if (db_type == "POSTGRESQL") {
            success = db_manager_.executeNonQueryPostgres("BEGIN");
        } else {
            success = db_manager_.executeNonQuerySQLite("BEGIN");
        }
        
        if (success) {
            transaction_active_ = true;
            transaction_count_++;
            logger_.Info("Global transaction started");
        }
        
        return success;
        
    } catch (const std::exception& e) {
        logger_.Error("Failed to begin global transaction: " + std::string(e.what()));
        error_count_++;
        return false;
    }
}

bool RepositoryFactory::commitGlobalTransaction() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    if (!transaction_active_) {
        logger_.Warn("No active global transaction to commit");
        return true;
    }
    
    try {
        std::string db_type = config_manager_.getOrDefault("DATABASE_TYPE", "SQLITE");
        
        bool success = false;
        if (db_type == "POSTGRESQL") {
            success = db_manager_.executeNonQueryPostgres("COMMIT");
        } else {
            success = db_manager_.executeNonQuerySQLite("COMMIT");
        }
        
        transaction_active_ = false;
        
        if (success) {
            logger_.Info("Global transaction committed");
        } else {
            logger_.Error("Failed to commit global transaction");
            error_count_++;
        }
        
        return success;
        
    } catch (const std::exception& e) {
        logger_.Error("Failed to commit global transaction: " + std::string(e.what()));
        transaction_active_ = false;
        error_count_++;
        return false;
    }
}

bool RepositoryFactory::rollbackGlobalTransaction() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    if (!transaction_active_) {
        logger_.Warn("No active global transaction to rollback");
        return true;
    }
    
    try {
        std::string db_type = config_manager_.getOrDefault("DATABASE_TYPE", "SQLITE");
        
        bool success = false;
        if (db_type == "POSTGRESQL") {
            success = db_manager_.executeNonQueryPostgres("ROLLBACK");
        } else {
            success = db_manager_.executeNonQuerySQLite("ROLLBACK");
        }
        
        transaction_active_ = false;  // Î°§Î∞± ÌõÑÏóêÎäî Ìï≠ÏÉÅ ÎπÑÌôúÏÑ±Ìôî
        
        if (success) {
            logger_.Info("Global transaction rolled back");
        } else {
            logger_.Error("Failed to rollback global transaction");
            error_count_++;
        }
        
        return success;
        
    } catch (const std::exception& e) {
        logger_.Error("Failed to rollback global transaction: " + std::string(e.what()));
        transaction_active_ = false;  // ÏóêÎü¨Í∞Ä ÎÇòÎèÑ Ìä∏ÎûúÏû≠ÏÖòÏùÄ ÎπÑÌôúÏÑ±Ìôî
        error_count_++;
        return false;
    }
}

bool RepositoryFactory::executeInGlobalTransaction(std::function<bool()> work) {
    if (!beginGlobalTransaction()) {
        return false;
    }
    
    try {
        if (work()) {
            return commitGlobalTransaction();
        } else {
            rollbackGlobalTransaction();
            return false;
        }
    } catch (const std::exception& e) {
        logger_.Error("executeInGlobalTransaction work failed: " + std::string(e.what()));
        rollbackGlobalTransaction();
        error_count_++;
        return false;
    }
}

// =============================================================================
// Ï∫êÏã± Ï†úÏñ¥
// =============================================================================

void RepositoryFactory::setCacheEnabled(bool enabled) {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    global_cache_enabled_ = enabled;
    
    logger_.Info("Global cache " + std::string(enabled ? "enabled" : "disabled"));
    
    // Í∞Å RepositoryÏóê Ï∫êÏãú ÏÑ§Ï†ï Ï†ÅÏö©
    if (device_repository_) {
        device_repository_->setCacheEnabled(enabled);
    }
    if (data_point_repository_) {
        data_point_repository_->setCacheEnabled(enabled);
    }
    if (user_repository_) {
        user_repository_->setCacheEnabled(enabled);
    }
    if (tenant_repository_) {
        tenant_repository_->setCacheEnabled(enabled);
    }
    if (alarm_config_repository_) {
        alarm_config_repository_->setCacheEnabled(enabled);
    }
    if (site_repository_) {
        site_repository_->setCacheEnabled(enabled);
    }
    if (virtual_point_repository_) {
        virtual_point_repository_->setCacheEnabled(enabled);
    }
    // üÜï CurrentValueRepository Ï∫êÏãú ÏÑ§Ï†ï Ï∂îÍ∞Ä
    if (current_value_repository_) {
        current_value_repository_->setCacheEnabled(enabled);
    }
}

void RepositoryFactory::clearAllCaches() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    logger_.Info("Clearing all repository caches...");
    
    int total_cleared = 0;
    
    // Í∞Å Repository Ï∫êÏãú ÌÅ¥Î¶¨Ïñ¥
    if (device_repository_) {
        try {
            auto stats = device_repository_->getCacheStats();
            int cached_items = stats["cached_items"];
            device_repository_->clearCache();
            total_cleared += cached_items;
        } catch (const std::exception& e) {
            logger_.Error("Failed to clear DeviceRepository cache: " + std::string(e.what()));
            error_count_++;
        }
    }
    
    if (data_point_repository_) {
        try {
            auto stats = data_point_repository_->getCacheStats();
            int cached_items = stats["cached_items"];
            data_point_repository_->clearCache();
            total_cleared += cached_items;
        } catch (const std::exception& e) {
            logger_.Error("Failed to clear DataPointRepository cache: " + std::string(e.what()));
            error_count_++;
        }
    }
    
    if (user_repository_) {
        try {
            auto stats = user_repository_->getCacheStats();
            int cached_items = stats["cached_items"];
            user_repository_->clearCache();
            total_cleared += cached_items;
        } catch (const std::exception& e) {
            logger_.Error("Failed to clear UserRepository cache: " + std::string(e.what()));
            error_count_++;
        }
    }
    
    if (tenant_repository_) {
        try {
            auto stats = tenant_repository_->getCacheStats();
            int cached_items = stats["cached_items"];
            tenant_repository_->clearCache();
            total_cleared += cached_items;
        } catch (const std::exception& e) {
            logger_.Error("Failed to clear TenantRepository cache: " + std::string(e.what()));
            error_count_++;
        }
    }
    
    if (alarm_config_repository_) {
        try {
            auto stats = alarm_config_repository_->getCacheStats();
            int cached_items = stats["cached_items"];
            alarm_config_repository_->clearCache();
            total_cleared += cached_items;
        } catch (const std::exception& e) {
            logger_.Error("Failed to clear AlarmConfigRepository cache: " + std::string(e.what()));
            error_count_++;
        }
    }
    
    if (site_repository_) {
        try {
            auto stats = site_repository_->getCacheStats();
            int cached_items = stats["cached_items"];
            site_repository_->clearCache();
            total_cleared += cached_items;
        } catch (const std::exception& e) {
            logger_.Error("Failed to clear SiteRepository cache: " + std::string(e.what()));
            error_count_++;
        }
    }
    
    if (virtual_point_repository_) {
        try {
            auto stats = virtual_point_repository_->getCacheStats();
            int cached_items = stats["cached_items"];
            virtual_point_repository_->clearCache();
            total_cleared += cached_items;
        } catch (const std::exception& e) {
            logger_.Error("Failed to clear VirtualPointRepository cache: " + std::string(e.what()));
            error_count_++;
        }
    }
    
    // üÜï CurrentValueRepository Ï∫êÏãú ÌÅ¥Î¶¨Ïñ¥ Ï∂îÍ∞Ä
    if (current_value_repository_) {
        try {
            auto stats = current_value_repository_->getCacheStats();
            int cached_items = stats["cached_items"];
            current_value_repository_->clearCache();
            total_cleared += cached_items;
        } catch (const std::exception& e) {
            logger_.Error("Failed to clear CurrentValueRepository cache: " + std::string(e.what()));
            error_count_++;
        }
    }
    
    logger_.Info("Cleared " + std::to_string(total_cleared) + " cached items from all repositories");
}

std::map<std::string, std::map<std::string, int>> RepositoryFactory::getAllCacheStats() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    std::map<std::string, std::map<std::string, int>> stats;
    
    if (initialized_) {
        // Í∞Å RepositoryÏùò Ï∫êÏãú ÌÜµÍ≥Ñ ÏàòÏßë
        if (device_repository_) {
            try {
                stats["DeviceRepository"] = device_repository_->getCacheStats();
            } catch (const std::exception& e) {
                logger_.Error("Failed to get DeviceRepository cache stats: " + std::string(e.what()));
                stats["DeviceRepository"] = {{"error", 1}};
            }
        }
        
        if (data_point_repository_) {
            try {
                stats["DataPointRepository"] = data_point_repository_->getCacheStats();
            } catch (const std::exception& e) {
                logger_.Error("Failed to get DataPointRepository cache stats: " + std::string(e.what()));
                stats["DataPointRepository"] = {{"error", 1}};
            }
        }
        
        if (user_repository_) {
            try {
                stats["UserRepository"] = user_repository_->getCacheStats();
            } catch (const std::exception& e) {
                logger_.Error("Failed to get UserRepository cache stats: " + std::string(e.what()));
                stats["UserRepository"] = {{"error", 1}};
            }
        }
        
        if (tenant_repository_) {
            try {
                stats["TenantRepository"] = tenant_repository_->getCacheStats();
            } catch (const std::exception& e) {
                logger_.Error("Failed to get TenantRepository cache stats: " + std::string(e.what()));
                stats["TenantRepository"] = {{"error", 1}};
            }
        }
        
        if (alarm_config_repository_) {
            try {
                stats["AlarmConfigRepository"] = alarm_config_repository_->getCacheStats();
            } catch (const std::exception& e) {
                logger_.Error("Failed to get AlarmConfigRepository cache stats: " + std::string(e.what()));
                stats["AlarmConfigRepository"] = {{"error", 1}};
            }
        }
        
        if (site_repository_) {
            try {
                stats["SiteRepository"] = site_repository_->getCacheStats();
            } catch (const std::exception& e) {
                logger_.Error("Failed to get SiteRepository cache stats: " + std::string(e.what()));
                stats["SiteRepository"] = {{"error", 1}};
            }
        }
        
        if (virtual_point_repository_) {
            try {
                stats["VirtualPointRepository"] = virtual_point_repository_->getCacheStats();
            } catch (const std::exception& e) {
                logger_.Error("Failed to get VirtualPointRepository cache stats: " + std::string(e.what()));
                stats["VirtualPointRepository"] = {{"error", 1}};
            }
        }
        
        // üÜï CurrentValueRepository Ï∫êÏãú ÌÜµÍ≥Ñ Ï∂îÍ∞Ä
        if (current_value_repository_) {
            try {
                stats["CurrentValueRepository"] = current_value_repository_->getCacheStats();
            } catch (const std::exception& e) {
                logger_.Error("Failed to get CurrentValueRepository cache stats: " + std::string(e.what()));
                stats["CurrentValueRepository"] = {{"error", 1}};
            }
        }
    }
    
    return stats;
}

void RepositoryFactory::setCacheTTL(int ttl_seconds) {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    cache_ttl_seconds_ = ttl_seconds;
    
    logger_.Info("Cache TTL set to " + std::to_string(ttl_seconds) + " seconds");
    
    // RepositoryÎ≥Ñ ÏÑ§Ï†ï Ï†ÅÏö© (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Í∞Å RepositoryÏóê TTL ÏÑ§Ï†ï Î©îÏÑúÎìú ÌïÑÏöî)
    // applyRepositoryConfigurations();
}

void RepositoryFactory::setMaxCacheSize(int max_size) {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    max_cache_size_ = max_size;
    
    logger_.Info("Max cache size set to " + std::to_string(max_size) + " entries");
    
    // RepositoryÎ≥Ñ ÏÑ§Ï†ï Ï†ÅÏö© (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Í∞Å RepositoryÏóê ÌÅ¨Í∏∞ ÏÑ§Ï†ï Î©îÏÑúÎìú ÌïÑÏöî)
    // applyRepositoryConfigurations();
}

// =============================================================================
// ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ
// =============================================================================

std::map<std::string, int> RepositoryFactory::getFactoryStats() const {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    std::map<std::string, int> stats;
    
    stats["initialized"] = initialized_ ? 1 : 0;
    stats["active_repositories"] = getActiveRepositoryCount();
    stats["creation_count"] = creation_count_;
    stats["error_count"] = error_count_;
    stats["transaction_count"] = transaction_count_;
    stats["cache_enabled"] = global_cache_enabled_ ? 1 : 0;
    stats["cache_ttl_seconds"] = cache_ttl_seconds_;
    stats["max_cache_size"] = max_cache_size_;
    stats["transaction_active"] = transaction_active_ ? 1 : 0;
    
    return stats;
}

int RepositoryFactory::getActiveRepositoryCount() const {
    int count = 0;
    
    if (device_repository_) count++;
    if (data_point_repository_) count++;
    if (user_repository_) count++;
    if (tenant_repository_) count++;
    if (alarm_config_repository_) count++;
    if (site_repository_) count++;
    if (virtual_point_repository_) count++;
    if (current_value_repository_) count++;  // üÜï Ï∂îÍ∞Ä
    
    return count;
}

bool RepositoryFactory::reloadConfigurations() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    if (!initialized_) {
        logger_.Warn("RepositoryFactory not initialized for configuration reload");
        return false;
    }
    
    try {
        logger_.Info("Reloading repository configurations...");
        
        // ConfigManagerÏóêÏÑú ÏµúÏã† ÏÑ§Ï†ï Î°úÎìú
        cache_ttl_seconds_ = std::stoi(config_manager_.getOrDefault("REPOSITORY_CACHE_TTL_SECONDS", "300"));
        max_cache_size_ = std::stoi(config_manager_.getOrDefault("REPOSITORY_MAX_CACHE_SIZE", "1000"));
        global_cache_enabled_ = (config_manager_.getOrDefault("REPOSITORY_CACHE_ENABLED", "true") == "true");
        
        // RepositoryÎ≥Ñ ÏÑ§Ï†ï Ï†ÅÏö©
        applyRepositoryConfigurations();
        
        logger_.Info("Repository configurations reloaded successfully");
        return true;
        
    } catch (const std::exception& e) {
        logger_.Error("reloadConfigurations failed: " + std::string(e.what()));
        error_count_++;
        return false;
    }
}

void RepositoryFactory::resetStats() {
    std::lock_guard<std::mutex> lock(factory_mutex_);
    
    creation_count_ = 0;
    error_count_ = 0;
    transaction_count_ = 0;
    
    logger_.Info("RepositoryFactory statistics reset");
}

// =============================================================================
// ÎÇ¥Î∂Ä Ìó¨Ìçº Î©îÏÑúÎìúÎì§
// =============================================================================

bool RepositoryFactory::createRepositoryInstances() {
    try {
        logger_.Info("Creating repository instances...");
        
        // DeviceRepository ÏÉùÏÑ±
        device_repository_ = std::make_unique<DeviceRepository>();
        if (!device_repository_) {
            logger_.Error("Failed to create DeviceRepository");
            return false;
        }
        
        // DataPointRepository ÏÉùÏÑ±
        data_point_repository_ = std::make_unique<DataPointRepository>();
        if (!data_point_repository_) {
            logger_.Error("Failed to create DataPointRepository");
            return false;
        }
        
        // UserRepository ÏÉùÏÑ±
        user_repository_ = std::make_unique<UserRepository>();
        if (!user_repository_) {
            logger_.Error("Failed to create UserRepository");
            return false;
        }
        
        // TenantRepository ÏÉùÏÑ±
        tenant_repository_ = std::make_unique<TenantRepository>();
        if (!tenant_repository_) {
            logger_.Error("Failed to create TenantRepository");
            return false;
        }
        
        // AlarmConfigRepository ÏÉùÏÑ±
        alarm_config_repository_ = std::make_unique<AlarmConfigRepository>();
        if (!alarm_config_repository_) {
            logger_.Error("Failed to create AlarmConfigRepository");
            return false;
        }
        
        // SiteRepository ÏÉùÏÑ±
        site_repository_ = std::make_unique<SiteRepository>();
        if (!site_repository_) {
            logger_.Error("Failed to create SiteRepository");
            return false;
        }

        // VirtualPointRepository ÏÉùÏÑ±
        virtual_point_repository_ = std::make_unique<VirtualPointRepository>();
        if (!virtual_point_repository_) {
            logger_.Error("Failed to create VirtualPointRepository");
            return false;
        }
        
        // üÜï CurrentValueRepository ÏÉùÏÑ±
        current_value_repository_ = std::make_unique<CurrentValueRepository>();
        if (!current_value_repository_) {
            logger_.Error("Failed to create CurrentValueRepository");
            return false;
        }
        
        logger_.Info("All repository instances created successfully");
        return true;
        
    } catch (const std::exception& e) {
        logger_.Error("RepositoryFactory::createRepositoryInstances failed: " + std::string(e.what()));
        error_count_++;
        return false;
    }
}

void RepositoryFactory::applyRepositoryConfigurations() {
    try {
        logger_.Info("Applying repository configurations...");
        
        // Ï†ÑÏó≠ Ï∫êÏãú ÏÑ§Ï†ï Ï†ÅÏö©
        setCacheEnabled(global_cache_enabled_);
        
        // Í∞úÎ≥Ñ RepositoryÎ≥Ñ ÏÑ§Ï†ï (ÌïÑÏöîÏãú)
        // ÌòÑÏû¨Îäî Ï†ÑÏó≠ ÏÑ§Ï†ïÎßå Ï†ÅÏö©ÌïòÏßÄÎßå, Ìñ•ÌõÑ RepositoryÎ≥Ñ Í∞úÎ≥Ñ ÏÑ§Ï†ï Í∞ÄÎä•
        
        logger_.Info("Repository configurations applied successfully");
        
    } catch (const std::exception& e) {
        logger_.Error("RepositoryFactory::applyRepositoryConfigurations failed: " + std::string(e.what()));
        error_count_++;
    }
}

bool RepositoryFactory::injectDependencies() {
    try {
        logger_.Info("Injecting dependencies into repositories...");
        
        // ÌòÑÏû¨Îäî RepositoryÎì§Ïù¥ ÏÉùÏÑ±ÏûêÏóêÏÑú Ïã±Í∏ÄÌÜ§ Ï∞∏Ï°∞Î•º Î∞õÏïÑÏò§ÎØÄÎ°ú Î≥ÑÎèÑ Ï£ºÏûÖ Î∂àÌïÑÏöî
        // Ìñ•ÌõÑ DI Ïª®ÌÖåÏù¥ÎÑà Ìå®ÌÑ¥ÏúºÎ°ú Î∞úÏ†ÑÏãúÌÇ¨ Îïå Ïù¥ Î©îÏÑúÎìúÏóêÏÑú ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ ÏàòÌñâ
        
        logger_.Info("Dependencies injected successfully");
        return true;
        
    } catch (const std::exception& e) {
        logger_.Error("RepositoryFactory::injectDependencies failed: " + std::string(e.what()));
        error_count_++;
        return false;
    }
}

} // namespace Database
} // namespace PulseOne