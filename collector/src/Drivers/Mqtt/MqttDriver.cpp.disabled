// =============================================================================
// collector/src/Drivers/MqttDriver.cpp
// MQTT 드라이버 구현
// =============================================================================

#include "Drivers/Mqtt/MqttDriver.h"
#include "Drivers/Common/DriverFactory.h"
#include <sstream>
#include <iomanip>
#include <algorithm>

using namespace PulseOne::Drivers;
using namespace std::chrono;

// =============================================================================
// 생성자/소멸자
// =============================================================================

MqttDriver::MqttDriver()
    : status_(DriverStatus::UNINITIALIZED)
    , is_connected_(false)
    , connection_in_progress_(false)
    , stop_workers_(false)
    , need_reconnect_(false)
    , last_successful_operation_(system_clock::now())
    , total_messages_received_(0)
    , total_messages_sent_(0)
    , total_bytes_received_(0)
    , total_bytes_sent_(0)
{
}

MqttDriver::~MqttDriver() {
    Disconnect();
    StopBackgroundTasks();
}

// =============================================================================
// IProtocolDriver 인터페이스 구현
// =============================================================================

bool MqttDriver::Initialize(const DriverConfig& config) {
    config_ = config;
    
    // 로거 초기화
    logger_ = std::make_unique<DriverLogger>(
        config_.device_id,
        ProtocolType::MQTT,
        config_.endpoint
    );
    
    logger_->Info("MQTT driver initialization started", DriverLogCategory::GENERAL);
    
    try {
        // 설정 파싱
        if (!ParseConfig(config)) {
            return false;
        }
        
        // MQTT 클라이언트 생성
        if (!CreateMqttClient()) {
            return false;
        }
        
        // 콜백 설정
        SetupCallbacks();
        
        // SSL 설정 (필요한 경우)
        if (mqtt_config_.use_ssl) {
            if (!SetupSslOptions()) {
                return false;
            }
        }
        
        // 백그라운드 작업 시작
        StartBackgroundTasks();
        
        status_ = DriverStatus::INITIALIZED;
        
        logger_->Info("MQTT driver initialized successfully", DriverLogCategory::GENERAL);
        
        // 통계 초기화
        ResetStatistics();
        
        return true;
        
    } catch (const std::exception& e) {
        SetError(ErrorCode::CONFIGURATION_ERROR, 
                 "Initialization error: " + std::string(e.what()));
        return false;
    }
}

bool MqttDriver::ParseConfig(const DriverConfig& config) {
    // 브로커 URL 파싱
    mqtt_config_.broker_url = config.endpoint;
    
    // 클라이언트 ID 생성 (디바이스 ID 기반)
    mqtt_config_.client_id = "pulseone_" + config.device_id.substr(0, 8);
    
    // 인증 정보
    mqtt_config_.username = config.username;
    mqtt_config_.password = config.password;
    
    // SSL 설정
    mqtt_config_.use_ssl = config.use_ssl;
    mqtt_config_.ca_cert_path = config.certificate_path;
    
    // 프로토콜별 설정 파싱
    auto settings = config.protocol_settings;
    
    // Keep Alive 간격
    auto it = settings.find("keep_alive");
    if (it != settings.end()) {
        mqtt_config_.keep_alive_interval = std::stoi(it->second);
    }
    
    // Clean Session
    it = settings.find("clean_session");
    if (it != settings.end()) {
        mqtt_config_.clean_session = (it->second == "true" || it->second == "1");
    }
    
    // 최대 인플라이트 메시지
    it = settings.find("max_inflight");
    if (it != settings.end()) {
        mqtt_config_.max_inflight = std::stoi(it->second);
    }
    
    // 연결 타임아웃
    it = settings.find("connection_timeout");
    if (it != settings.end()) {
        mqtt_config_.connection_timeout = std::stoi(it->second);
    }
    
    // 재연결 간격
    it = settings.find("retry_interval");
    if (it != settings.end()) {
        mqtt_config_.retry_interval = std::stoi(it->second);
    }
    
    // 자동 재연결
    it = settings.find("auto_reconnect");
    if (it != settings.end()) {
        mqtt_config_.auto_reconnect = (it->second == "true" || it->second == "1");
    }
    
    logger_->Info("MQTT configuration parsed: broker=" + mqtt_config_.broker_url + 
                  ", client=" + mqtt_config_.client_id,
                  DriverLogCategory::GENERAL);
    
    return true;
}

bool MqttDriver::CreateMqttClient() {
    try {
        client_ = std::make_unique<mqtt::async_client>(
            mqtt_config_.broker_url, 
            mqtt_config_.client_id
        );
        
        logger_->Info("MQTT client created successfully", DriverLogCategory::CONNECTION);
        return true;
        
    } catch (const mqtt::exception& e) {
        SetError(ErrorCode::INSUFFICIENT_RESOURCES, 
                 "Failed to create MQTT client: " + std::string(e.what()));
        return false;
    }
}

void MqttDriver::SetupCallbacks() {
    client_->set_callback(*this);
    
    // 연결 옵션 설정
    connect_opts_.set_keep_alive_interval(mqtt_config_.keep_alive_interval);
    connect_opts_.set_clean_session(mqtt_config_.clean_session);
    connect_opts_.set_automatic_reconnect(mqtt_config_.auto_reconnect);
    connect_opts_.set_max_inflight(mqtt_config_.max_inflight);
    
    // 인증 정보 설정
    if (!mqtt_config_.username.empty()) {
        connect_opts_.set_user_name(mqtt_config_.username);
        connect_opts_.set_password(mqtt_config_.password);
    }
    
    // SSL 옵션 설정 (필요한 경우)
    if (mqtt_config_.use_ssl) {
        connect_opts_.set_ssl(ssl_opts_);
    }
    
    logger_->Info("MQTT callbacks and options configured", DriverLogCategory::CONNECTION);
}

bool MqttDriver::SetupSslOptions() {
    try {
        if (!mqtt_config_.ca_cert_path.empty()) {
            ssl_opts_.set_trust_store(mqtt_config_.ca_cert_path);
        }
        
        if (!mqtt_config_.client_cert_path.empty()) {
            ssl_opts_.set_key_store(mqtt_config_.client_cert_path);
        }
        
        ssl_opts_.set_ssl_version(mqtt::ssl_options::SSLVERSION_TLS_1_2);
        ssl_opts_.set_verify(true);
        ssl_opts_.set_alpn_protos({"mqtt"});
        
        logger_->Info("SSL options configured", DriverLogCategory::SECURITY);
        return true;
        
    } catch (const std::exception& e) {
        SetError(ErrorCode::CONFIGURATION_ERROR, 
                 "SSL configuration error: " + std::string(e.what()));
        return false;
    }
}

bool MqttDriver::Connect() {
    if (is_connected_) {
        return true;
    }
    
    if (connection_in_progress_) {
        // 이미 연결 시도 중
        return false;
    }
    
    connection_in_progress_ = true;
    status_ = DriverStatus::CONNECTING;
    
    logger_->Info("Attempting to connect to MQTT broker", DriverLogCategory::CONNECTION);
    
    bool success = EstablishConnection();
    
    connection_in_progress_ = false;
    
    return success;
}

bool MqttDriver::EstablishConnection() {
    try {
        auto connection_start = steady_clock::now();
        
        // 비동기 연결 시도
        auto tok = client_->connect(connect_opts_, nullptr, *this);
        
        // 연결 완료 대기 (타임아웃 적용)
        bool connected = tok->wait_for(std::chrono::seconds(mqtt_config_.connection_timeout));
        
        auto connection_end = steady_clock::now();
        auto duration_ms = duration_cast<milliseconds>(connection_end - connection_start).count();
        
        if (connected && client_->is_connected()) {
            is_connected_ = true;
            status_ = DriverStatus::CONNECTED;
            last_successful_operation_ = system_clock::now();
            
            {
                std::lock_guard<std::mutex> lock(stats_mutex_);
                statistics_.connection_attempts++;
                statistics_.successful_connections++;
            }
            
            logger_->LogMqttConnectionStatus(true, mqtt_config_.broker_url,
                                           "Connected in " + std::to_string(duration_ms) + "ms");
            
            // 기존 구독 복원
            RestoreSubscriptions();
            
            NotifyConnectionStatusChanged(config_.device_id,
                                          ConnectionStatus::DISCONNECTED,
                                          ConnectionStatus::CONNECTED,
                                          "Connected");
            
            UpdateDiagnostics();
            return true;
            
        } else {
            SetError(ErrorCode::CONNECTION_FAILED, 
                     "Connection timeout after " + std::to_string(duration_ms) + "ms");
            
            {
                std::lock_guard<std::mutex> lock(stats_mutex_);
                statistics_.connection_attempts++;
            }
            
            logger_->LogMqttConnectionStatus(false, mqtt_config_.broker_url,
                                           "Connection failed after " + std::to_string(duration_ms) + "ms");
            
            status_ = DriverStatus::ERROR;
            return false;
        }
        
    } catch (const mqtt::exception& e) {
        SetError(ErrorCode::CONNECTION_FAILED, 
                 "MQTT connection error: " + std::string(e.what()));
        
        {
            std::lock_guard<std::mutex> lock(stats_mutex_);
            statistics_.connection_attempts++;
        }
        
        logger_->LogMqttConnectionStatus(false, mqtt_config_.broker_url,
                                       "Exception: " + std::string(e.what()));
        
        status_ = DriverStatus::ERROR;
        return false;
    }
}

bool MqttDriver::Disconnect() {
    if (!is_connected_) {
        return true;
    }
    
    status_ = DriverStatus::DISCONNECTING;
    logger_->Info("Disconnecting from MQTT broker", DriverLogCategory::CONNECTION);
    
    try {
        if (client_ && client_->is_connected()) {
            auto tok = client_->disconnect();
            tok->wait_for(std::chrono::seconds(10));  // 10초 타임아웃
        }
        
        is_connected_ = false;
        status_ = DriverStatus::DISCONNECTED;
        
        logger_->LogMqttConnectionStatus(false, mqtt_config_.broker_url, "Disconnected");
        
        NotifyConnectionStatusChanged(config_.device_id,
                                      ConnectionStatus::CONNECTED,
                                      ConnectionStatus::DISCONNECTED,
                                      "Disconnected");
        
        return true;
        
    } catch (const mqtt::exception& e) {
        SetError(ErrorCode::UNKNOWN_ERROR, 
                 "Disconnect error: " + std::string(e.what()));
        
        // 강제로 연결 상태 해제
        is_connected_ = false;
        status_ = DriverStatus::ERROR;
        
        return false;
    }
}

bool MqttDriver::IsConnected() const {
    return is_connected_ && client_ && client_->is_connected();
}

ProtocolType MqttDriver::GetProtocolType() const {
    return ProtocolType::MQTT;
}

DriverStatus MqttDriver::GetStatus() const {
    return status_;
}

ErrorInfo MqttDriver::GetLastError() const {
    std::lock_guard<std::mutex> lock(error_mutex_);
    return last_error_;
}

// =============================================================================
// 데이터 읽기/쓰기 구현
// =============================================================================

bool MqttDriver::ReadValues(const std::vector<DataPoint>& points,
                           std::vector<TimestampedValue>& values) {
    if (!IsConnected()) {
        SetError(ErrorCode::CONNECTION_FAILED, "Not connected to MQTT broker");
        return false;
    }
    
    std::lock_guard<std::mutex> lock(values_mutex_);
    
    values.clear();
    values.reserve(points.size());
    
    bool overall_success = true;
    
    for (const auto& point : points) {
        auto it = latest_values_.find(point.id);
        if (it != latest_values_.end()) {
            // 최신 값이 있음
            values.push_back(it->second);
            
            // 값이 너무 오래된 경우 품질을 UNCERTAIN으로 설정
            auto age = system_clock::now() - it->second.timestamp;
            if (age > std::chrono::minutes(5)) {  // 5분 이상 오래된 데이터
                values.back().quality = DataQuality::UNCERTAIN;
            }
        } else {
            // 값이 없음
            TimestampedValue no_value;
            no_value.value = DataValue(0);
            no_value.quality = DataQuality::NOT_CONNECTED;
            no_value.timestamp = system_clock::now();
            values.push_back(no_value);
            overall_success = false;
        }
    }
    
    UpdateStatistics("read", overall_success);
    
    if (overall_success) {
        last_successful_operation_ = system_clock::now();
    }
    
    return overall_success;
}

bool MqttDriver::WriteValue(const DataPoint& point, const DataValue& value) {
    if (!IsConnected()) {
        SetError(ErrorCode::CONNECTION_FAILED, "Not connected to MQTT broker");
        return false;
    }
    
    try {
        // 토픽 결정
        std::string topic;
        auto topic_it = point.properties.find("write_topic");
        if (topic_it != point.properties.end()) {
            topic = topic_it->second;
        } else {
            // 기본 토픽 생성: write/{device_name}/{point_name}
            topic = "write/" + config_.device_name + "/" + point.name;
        }
        
        // QoS 결정
        int qos = 1;  // 기본값
        auto qos_it = point.properties.find("qos");
        if (qos_it != point.properties.end()) {
            qos = std::stoi(qos_it->second);
        }
        
        // 값을 문자열로 변환
        std::string payload;
        if (std::holds_alternative<bool>(value)) {
            payload = std::get<bool>(value) ? "true" : "false";
        } else if (std::holds_alternative<int16_t>(value)) {
            payload = std::to_string(std::get<int16_t>(value));
        } else if (std::holds_alternative<uint16_t>(value)) {
            payload = std::to_string(std::get<uint16_t>(value));
        } else if (std::holds_alternative<int32_t>(value)) {
            payload = std::to_string(std::get<int32_t>(value));
        } else if (std::holds_alternative<uint32_t>(value)) {
            payload = std::to_string(std::get<uint32_t>(value));
        } else if (std::holds_alternative<float>(value)) {
            payload = std::to_string(std::get<float>(value));
        } else if (std::holds_alternative<double>(value)) {
            payload = std::to_string(std::get<double>(value));
        } else if (std::holds_alternative<std::string>(value)) {
            payload = std::get<std::string>(value);
        } else {
            SetError(ErrorCode::DATA_FORMAT_ERROR, "Unsupported data type for MQTT write");
            return false;
        }
        
        // 메시지 발행
        bool success = Publish(topic, payload, qos, false);
        
        UpdateStatistics("write", success);
        
        if (success) {
            last_successful_operation_ = system_clock::now();
            
            logger_->LogMqttOperation("PUBLISH", topic, qos, payload.length(), true);
        } else {
            logger_->LogMqttOperation("PUBLISH", topic, qos, payload.length(), false);
        }
        
        return success;
        
    } catch (const std::exception& e) {
        SetError(ErrorCode::DATA_FORMAT_ERROR, 
                 "Write value error: " + std::string(e.what()));
        
        UpdateStatistics("write", false);
        return false;
    }
}

// =============================================================================
// MQTT 특화 메소드 구현
// =============================================================================

bool MqttDriver::Subscribe(const std::string& topic, int qos) {
    if (!IsConnected()) {
        SetError(ErrorCode::CONNECTION_FAILED, "Not connected to MQTT broker");
        return false;
    }
    
    try {
        auto tok = client_->subscribe(topic, qos, nullptr, *this);
        bool success = tok->wait_for(std::chrono::seconds(10));
        
        if (success) {
            std::lock_guard<std::mutex> lock(subscriptions_mutex_);
            subscriptions_[topic] = SubscriptionInfo(topic, qos);
            subscriptions_[topic].subscribed = true;
            
            logger_->LogMqttOperation("SUBSCRIBE", topic, qos, 0, true);
            
            UpdateStatistics("subscribe", true);
            return true;
        } else {
            SetError(ErrorCode::TIMEOUT, "Subscribe timeout for topic: " + topic);
            
            logger_->LogMqttOperation("SUBSCRIBE", topic, qos, 0, false);
            
            UpdateStatistics("subscribe", false);
            return false;
        }
        
    } catch (const mqtt::exception& e) {
        SetError(ErrorCode::PROTOCOL_ERROR, 
                 "Subscribe error: " + std::string(e.what()));
        
        logger_->LogMqttOperation("SUBSCRIBE", topic, qos, 0, false);
        
        UpdateStatistics("subscribe", false);
        return false;
    }
}

bool MqttDriver::Unsubscribe(const std::string& topic) {
    if (!IsConnected()) {
        return false;
    }
    
    try {
        auto tok = client_->unsubscribe(topic, nullptr, *this);
        bool success = tok->wait_for(std::chrono::seconds(10));
        
        if (success) {
            std::lock_guard<std::mutex> lock(subscriptions_mutex_);
            auto it = subscriptions_.find(topic);
            if (it != subscriptions_.end()) {
                it->second.subscribed = false;
            }
            
            logger_->LogMqttOperation("UNSUBSCRIBE", topic, 0, 0, true);
            
            UpdateStatistics("unsubscribe", true);
            return true;
        } else {
            SetError(ErrorCode::TIMEOUT, "Unsubscribe timeout for topic: " + topic);
            
            logger_->LogMqttOperation("UNSUBSCRIBE", topic, 0, 0, false);
            
            UpdateStatistics("unsubscribe", false);
            return false;
        }
        
    } catch (const mqtt::exception& e) {
        SetError(ErrorCode::PROTOCOL_ERROR, 
                 "Unsubscribe error: " + std::string(e.what()));
        
        logger_->LogMqttOperation("UNSUBSCRIBE", topic, 0, 0, false);
        
        UpdateStatistics("unsubscribe", false);
        return false;
    }
}

bool MqttDriver::Publish(const std::string& topic, const std::string& payload,
                        int qos, bool retained) {
    if (!IsConnected()) {
        SetError(ErrorCode::CONNECTION_FAILED, "Not connected to MQTT broker");
        return false;
    }
    
    try {
        auto msg = mqtt::make_message(topic, payload, qos, retained);
        auto tok = client_->publish(msg, nullptr, *this);
        
        // 비동기 발행이므로 즉시 성공으로 처리
        // 실제 결과는 delivery_complete 콜백에서 처리
        
        total_messages_sent_++;
        total_bytes_sent_ += payload.length();
        
        logger_->LogMqttOperation("PUBLISH", topic, qos, payload.length(), true);
        
        UpdateStatistics("publish", true);
        return true;
        
    } catch (const mqtt::exception& e) {
        SetError(ErrorCode::PROTOCOL_ERROR, 
                 "Publish error: " + std::string(e.what()));
        
        logger_->LogMqttOperation("PUBLISH", topic, qos, payload.length(), false);
        
        UpdateStatistics("publish", false);
        return false;
    }
}

bool MqttDriver::PublishJson(const std::string& topic, const Json::Value& json_data,
                            int qos, bool retained) {
    Json::StreamWriterBuilder builder;
    std::string payload = Json::writeString(builder, json_data);
    
    return Publish(topic, payload, qos, retained);
}

bool MqttDriver::PublishDataPoints(
    const std::vector<std::pair<DataPoint, TimestampedValue>>& data_points,
    const std::string& base_topic) {
    
    if (!IsConnected()) {
        return false;
    }
    
    bool overall_success = true;
    
    for (const auto& pair : data_points) {
        const DataPoint& point = pair.first;
        const TimestampedValue& value = pair.second;
        
        // JSON 메시지 생성
        Json::Value json_msg = CreateDataPointJson(point, value);
        
        // 토픽 생성
        std::string topic = base_topic + "/" + config_.device_name + "/" + point.name;
        
        // QoS 결정
        int qos = 1;
        auto qos_it = point.properties.find("qos");
        if (qos_it != point.properties.end()) {
            qos = std::stoi(qos_it->second);
        }
        
        // 발행
        bool success = PublishJson(topic, json_msg, qos, false);
        if (!success) {
            overall_success = false;
        }
    }
    
    return overall_success;
}

// =============================================================================
// MQTT 콜백 구현
// =============================================================================

void MqttDriver::connected(const std::string& cause) {
    logger_->Info("MQTT connected: " + cause, DriverLogCategory::CONNECTION);
    
    is_connected_ = true;
    status_ = DriverStatus::CONNECTED;
    last_successful_operation_ = system_clock::now();
    
    NotifyConnectionStatusChanged(config_.device_id,
                                  ConnectionStatus::CONNECTING,
                                  ConnectionStatus::CONNECTED,
                                  cause);
    
    // 기존 구독 복원
    RestoreSubscriptions();
    
    UpdateDiagnostics();
}

void MqttDriver::connection_lost(const std::string& cause) {
    logger_->Warn("MQTT connection lost: " + cause, DriverLogCategory::CONNECTION);
    
    is_connected_ = false;
    status_ = DriverStatus::ERROR;
    
    NotifyConnectionStatusChanged(config_.device_id,
                                  ConnectionStatus::CONNECTED,
                                  ConnectionStatus::ERROR,
                                  cause);
    
    // 자동 재연결 트리거
    if (mqtt_config_.auto_reconnect) {
        std::lock_guard<std::mutex> lock(reconnect_mutex_);
        need_reconnect_ = true;
        reconnect_cv_.notify_one();
    }
}

void MqttDriver::message_arrived(mqtt::const_message_ptr msg) {
    try {
        total_messages_received_++;
        total_bytes_received_ += msg->get_payload().length();
        
        logger_->LogMqttOperation("RECEIVE", msg->get_topic(), msg->get_qos(), 
                                 msg->get_payload().length(), true);
        
        ProcessIncomingMessage(msg);
        
        // 구독 통계 업데이트
        {
            std::lock_guard<std::mutex> lock(subscriptions_mutex_);
            auto it = subscriptions_.find(msg->get_topic());
            if (it != subscriptions_.end()) {
                it->second.message_count++;
                it->second.last_message = system_clock::now();
            }
        }
        
        last_successful_operation_ = system_clock::now();
        
    } catch (const std::exception& e) {
        logger_->Error("Message processing error: " + std::string(e.what()),
                      DriverLogCategory::ERROR_HANDLING);
    }
}

void MqttDriver::delivery_complete(mqtt::delivery_token_ptr tok) {
    logger_->LogMqttOperation("DELIVERED", tok->get_topic(), 0, 0, true);
    
    // 배달 완료 통계 업데이트
    UpdateStatistics("delivery", true);
}

// =============================================================================
// MQTT 액션 리스너 구현
// =============================================================================

void MqttDriver::on_failure(const mqtt::token& tok) {
    std::string operation = "unknown";
    if (tok.get_type() == mqtt::token::CONNECT) {
        operation = "connect";
    } else if (tok.get_type() == mqtt::token::SUBSCRIBE) {
        operation = "subscribe";
    } else if (tok.get_type() == mqtt::token::PUBLISH) {
        operation = "publish";
    }
    
    logger_->Error("MQTT " + operation + " failed for: " + 
                  (tok.get_topics().empty() ? "unknown" : tok.get_topics()[0]),
                  DriverLogCategory::ERROR_HANDLING);
    
    UpdateStatistics(operation, false);
}

void MqttDriver::on_success(const mqtt::token& tok) {
    std::string operation = "unknown";
    if (tok.get_type() == mqtt::token::CONNECT) {
        operation = "connect";
    } else if (tok.get_type() == mqtt::token::SUBSCRIBE) {
        operation = "subscribe";
        
        // 구독 성공 시 상태 업데이트
        for (const auto& topic : tok.get_topics()) {
            UpdateSubscriptionStatus(topic, true);
        }
    } else if (tok.get_type() == mqtt::token::PUBLISH) {
        operation = "publish";
    }
    
    logger_->Info("MQTT " + operation + " succeeded", DriverLogCategory::COMMUNICATION);
    
    UpdateStatistics(operation, true);
}

// =============================================================================
// 내부 헬퍼 메소드들 구현
// =============================================================================

void MqttDriver::ProcessIncomingMessage(mqtt::const_message_ptr msg) {
    std::string topic = msg->get_topic();
    std::string payload = msg->to_string();
    
    // 토픽에 매핑된 데이터 포인트들 찾기
    std::lock_guard<std::mutex> mapping_lock(data_mapping_mutex_);
    auto it = topic_to_datapoints_.find(topic);
    if (it == topic_to_datapoints_.end()) {
        // 매핑되지 않은 토픽
        logger_->Debug("Received message for unmapped topic: " + topic,
                      DriverLogCategory::COMMUNICATION);
        return;
    }
    
    // 각 데이터 포인트에 대해 값 업데이트
    std::vector<std::pair<UUID, TimestampedValue>> updated_points;
    
    for (const auto& point : it->second) {
        try {
            DataValue parsed_value = ParseMessagePayload(payload, point.data_type);
            
            TimestampedValue tvalue(parsed_value, DataQuality::GOOD);
            
            // 스케일링 적용 (필요한 경우)
            if (point.scaling_factor != 1.0 || point.scaling_offset != 0.0) {
                if (std::holds_alternative<double>(parsed_value)) {
                    double scaled = std::get<double>(parsed_value) * point.scaling_factor + point.scaling_offset;
                    tvalue.value = DataValue(scaled);
                } else if (std::holds_alternative<float>(parsed_value)) {
                    float scaled = std::get<float>(parsed_value) * point.scaling_factor + point.scaling_offset;
                    tvalue.value = DataValue(scaled);
                }
            }
            
            // 최신 값 저장
            {
                std::lock_guard<std::mutex> values_lock(values_mutex_);
                latest_values_[point.id] = tvalue;
            }
            
            updated_points.push_back({point.id, tvalue});
            
        } catch (const std::exception& e) {
            logger_->Error("Failed to parse message for point " + point.name + ": " + e.what(),
                          DriverLogCategory::DATA_PROCESSING);
            
            // 에러 값 저장
            TimestampedValue error_value(DataValue(0), DataQuality::BAD);
            {
                std::lock_guard<std::mutex> values_lock(values_mutex_);
                latest_values_[point.id] = error_value;
            }
        }
    }
    
    // 데이터 수신 콜백 호출
    if (!updated_points.empty()) {
        NotifyDataReceived(config_.device_id, updated_points);
    }
}

DataValue MqttDriver::ParseMessagePayload(const std::string& payload, DataType expected_type) {
    switch (expected_type) {
        case DataType::BOOL: {
            std::string lower_payload = payload;
            std::transform(lower_payload.begin(), lower_payload.end(), lower_payload.begin(), ::tolower);
            return DataValue(lower_payload == "true" || lower_payload == "1" || lower_payload == "on");
        }
        case DataType::INT16:
            return DataValue(static_cast<int16_t>(std::stoi(payload)));
        case DataType::UINT16:
            return DataValue(static_cast<uint16_t>(std::stoul(payload)));
        case DataType::INT32:
            return DataValue(static_cast<int32_t>(std::stoi(payload)));
        case DataType::UINT32:
            return DataValue(static_cast<uint32_t>(std::stoul(payload)));
        case DataType::FLOAT:
            return DataValue(std::stof(payload));
        case DataType::DOUBLE:
            return DataValue(std::stod(payload));
        case DataType::STRING:
            return DataValue(payload);
        default:
            throw std::invalid_argument("Unsupported data type for MQTT message parsing");
    }
}

Json::Value MqttDriver::CreateDataPointJson(const DataPoint& point, const TimestampedValue& value) {
    Json::Value json_obj;
    
    json_obj["id"] = point.id;
    json_obj["name"] = point.name;
    json_obj["timestamp"] = std::chrono::duration_cast<std::chrono::milliseconds>(
        value.timestamp.time_since_epoch()).count();
    json_obj["quality"] = static_cast<int>(value.quality);
    
    // 값 설정
    if (std::holds_alternative<bool>(value.value)) {
        json_obj["value"] = std::get<bool>(value.value);
    } else if (std::holds_alternative<int16_t>(value.value)) {
        json_obj["value"] = std::get<int16_t>(value.value);
    } else if (std::holds_alternative<uint16_t>(value.value)) {
        json_obj["value"] = std::get<uint16_t>(value.value);
    } else if (std::holds_alternative<int32_t>(value.value)) {
        json_obj["value"] = std::get<int32_t>(value.value);
    } else if (std::holds_alternative<uint32_t>(value.value)) {
        json_obj["value"] = Json::Value(std::get<uint32_t>(value.value));
    } else if (std::holds_alternative<float>(value.value)) {
        json_obj["value"] = std::get<float>(value.value);
    } else if (std::holds_alternative<double>(value.value)) {
        json_obj["value"] = std::get<double>(value.value);
    } else if (std::holds_alternative<std::string>(value.value)) {
        json_obj["value"] = std::get<std::string>(value.value);
    }
    
    // 메타데이터
    if (!point.unit.empty()) {
        json_obj["unit"] = point.unit;
    }
    
    json_obj["device"] = config_.device_name;
    
    return json_obj;
}

void MqttDriver::RestoreSubscriptions() {
    std::lock_guard<std::mutex> lock(subscriptions_mutex_);
    
    for (auto& pair : subscriptions_) {
        if (pair.second.subscribed) {
            // 구독 재시도
            try {
                auto tok = client_->subscribe(pair.first, pair.second.qos);
                // 비동기이므로 즉시 반환
                
                logger_->Info("Restoring subscription for topic: " + pair.first,
                             DriverLogCategory::CONNECTION);
                
            } catch (const mqtt::exception& e) {
                logger_->Error("Failed to restore subscription for topic " + pair.first + ": " + e.what(),
                              DriverLogCategory::ERROR_HANDLING);
                pair.second.subscribed = false;
            }
        }
    }
}

void MqttDriver::UpdateSubscriptionStatus(const std::string& topic, bool subscribed) {
    std::lock_guard<std::mutex> lock(subscriptions_mutex_);
    
    auto it = subscriptions_.find(topic);
    if (it != subscriptions_.end()) {
        it->second.subscribed = subscribed;
    }
}

// =============================================================================
// 통계 및 진단
// =============================================================================

void MqttDriver::SetError(ErrorCode code, const std::string& message) {
    std::lock_guard<std::mutex> lock(error_mutex_);
    
    last_error_.code = code;
    last_error_.message = message;
    last_error_.timestamp = system_clock::now();
    
    if (logger_) {
        logger_->Error(message, DriverLogCategory::ERROR_HANDLING);
    }
    
    NotifyError(config_.device_id, last_error_);
}

void MqttDriver::UpdateStatistics(const std::string& operation, bool success, double duration_ms) {
    std::lock_guard<std::mutex> lock(stats_mutex_);
    
    if (operation == "read" || operation == "subscribe" || operation == "receive") {
        statistics_.total_reads++;
        if (success) {
            statistics_.successful_reads++;
            statistics_.last_successful_read = system_clock::now();
        } else {
            statistics_.failed_reads++;
        }
    } else if (operation == "write" || operation == "publish") {
        statistics_.total_writes++;
        if (success) {
            statistics_.successful_writes++;
        } else {
            statistics_.failed_writes++;
        }
    }
    
    // 응답 시간 통계 (제공된 경우)
    if (duration_ms > 0) {
        if (statistics_.total_reads + statistics_.total_writes == 1) {
            statistics_.average_response_time_ms = duration_ms;
            statistics_.max_response_time_ms = duration_ms;
        } else {
            uint64_t total_ops = statistics_.total_reads + statistics_.total_writes;
            statistics_.average_response_time_ms = 
                (statistics_.average_response_time_ms * (total_ops - 1) + duration_ms) / total_ops;
            
            if (duration_ms > statistics_.max_response_time_ms) {
                statistics_.max_response_time_ms = duration_ms;
            }
        }
    }
    
    if (!success) {
        statistics_.last_error = system_clock::now();
        statistics_.last_error_info = last_error_;
    }
}

DriverStatistics MqttDriver::GetStatistics() const {
    std::lock_guard<std::mutex> lock(stats_mutex_);
    return statistics_;
}

void MqttDriver::ResetStatistics() {
    std::lock_guard<std::mutex> lock(stats_mutex_);
    statistics_.Reset();
    
    // MQTT 특화 통계 초기화
    total_messages_received_ = 0;
    total_messages_sent_ = 0;
    total_bytes_received_ = 0;
    total_bytes_sent_ = 0;
}

std::map<std::string, std::string> MqttDriver::GetDiagnostics() const {
    std::lock_guard<std::mutex> lock(diagnostics_mutex_);
    return diagnostics_;
}

void MqttDriver::UpdateDiagnostics() {
    std::lock_guard<std::mutex> lock(diagnostics_mutex_);
    
    diagnostics_["protocol"] = "MQTT";
    diagnostics_["broker_url"] = mqtt_config_.broker_url;
    diagnostics_["client_id"] = mqtt_config_.client_id;
    diagnostics_["status"] = std::to_string(static_cast<int>(status_));
    diagnostics_["connected"] = is_connected_ ? "true" : "false";
    
    // 연결 정보
    diagnostics_["keep_alive"] = std::to_string(mqtt_config_.keep_alive_interval);
    diagnostics_["clean_session"] = mqtt_config_.clean_session ? "true" : "false";
    diagnostics_["auto_reconnect"] = mqtt_config_.auto_reconnect ? "true" : "false";
    diagnostics_["ssl_enabled"] = mqtt_config_.use_ssl ? "true" : "false";
    
    // 구독 정보
    {
        std::lock_guard<std::mutex> sub_lock(subscriptions_mutex_);
        diagnostics_["active_subscriptions"] = std::to_string(subscriptions_.size());
        
        int subscribed_count = 0;
        for (const auto& pair : subscriptions_) {
            if (pair.second.subscribed) {
                subscribed_count++;
            }
        }
        diagnostics_["subscribed_topics"] = std::to_string(subscribed_count);
    }
    
    // 메시지 통계
    diagnostics_["messages_received"] = std::to_string(total_messages_received_.load());
    diagnostics_["messages_sent"] = std::to_string(total_messages_sent_.load());
    diagnostics_["bytes_received"] = std::to_string(total_bytes_received_.load());
    diagnostics_["bytes_sent"] = std::to_string(total_bytes_sent_.load());
    
    // 통계 정보
    {
        std::lock_guard<std::mutex> stats_lock(stats_mutex_);
        diagnostics_["total_operations"] = std::to_string(statistics_.total_reads + statistics_.total_writes);
        diagnostics_["success_rate"] = std::to_string(statistics_.GetSuccessRate()) + "%";
        diagnostics_["avg_response_time"] = std::to_string(statistics_.average_response_time_ms) + "ms";
        diagnostics_["max_response_time"] = std::to_string(statistics_.max_response_time_ms) + "ms";
    }
    
    // 마지막 활동 시간
    auto now = system_clock::now();
    auto last_activity_sec = duration_cast<seconds>(now - last_successful_operation_).count();
    diagnostics_["last_activity_sec"] = std::to_string(last_activity_sec);
    
    // Paho MQTT 버전 정보
    diagnostics_["paho_version"] = "1.3.12";  // 실제 버전으로 교체
}

// =============================================================================
// 백그라운드 작업 관리
// =============================================================================

void MqttDriver::StartBackgroundTasks() {
    stop_workers_ = false;
    
    // 발행 작업자 스레드 시작
    publish_worker_ = std::thread(&MqttDriver::PublishWorkerLoop, this);
    
    // 재연결 작업자 스레드 시작
    reconnect_worker_ = std::thread(&MqttDriver::ReconnectWorkerLoop, this);
    
    logger_->Info("MQTT background tasks started", DriverLogCategory::GENERAL);
}

void MqttDriver::StopBackgroundTasks() {
    stop_workers_ = true;
    
    // 모든 대기 중인 스레드 깨우기
    publish_queue_cv_.notify_all();
    reconnect_cv_.notify_all();
    
    // 스레드 종료 대기
    if (publish_worker_.joinable()) {
        publish_worker_.join();
    }
    
    if (reconnect_worker_.joinable()) {
        reconnect_worker_.join();
    }
    
    logger_->Info("MQTT background tasks stopped", DriverLogCategory::GENERAL);
}

void MqttDriver::PublishWorkerLoop() {
    while (!stop_workers_) {
        std::unique_ptr<PublishRequest> request;
        
        // 큐에서 요청 가져오기
        {
            std::unique_lock<std::mutex> lock(publish_queue_mutex_);
            publish_queue_cv_.wait(lock, [this] { 
                return !publish_queue_.empty() || stop_workers_; 
            });
            
            if (stop_workers_) {
                break;
            }
            
            if (!publish_queue_.empty()) {
                request = std::move(publish_queue_.front());
                publish_queue_.pop();
            }
        }
        
        // 요청 처리
        if (request) {
            auto start_time = steady_clock::now();
            
            bool success = Publish(request->topic, request->payload, 
                                 request->qos, request->retained);
            
            auto end_time = steady_clock::now();
            auto duration_ms = duration_cast<milliseconds>(end_time - start_time).count();
            
            // Promise 설정
            request->promise.set_value(success);
            
            // 성능 로깅
            logger_->LogPerformanceMetric("PublishAsync", duration_ms, "ms");
        }
    }
}

void MqttDriver::ReconnectWorkerLoop() {
    while (!stop_workers_) {
        std::unique_lock<std::mutex> lock(reconnect_mutex_);
        reconnect_cv_.wait(lock, [this] { 
            return need_reconnect_.load() || stop_workers_; 
        });
        
        if (stop_workers_) {
            break;
        }
        
        if (need_reconnect_.load()) {
            need_reconnect_ = false;
            lock.unlock();
            
            ProcessReconnection();
        }
    }
}

void MqttDriver::ProcessReconnection() {
    if (is_connected_) {
        return;  // 이미 연결됨
    }
    
    // 재연결 간격 체크
    auto now = steady_clock::now();
    auto time_since_last_attempt = duration_cast<seconds>(now - last_reconnect_attempt_).count();
    
    if (time_since_last_attempt < mqtt_config_.retry_interval) {
        // 아직 재연결 간격이 지나지 않음
        std::this_thread::sleep_for(std::chrono::seconds(
            mqtt_config_.retry_interval - time_since_last_attempt));
    }
    
    last_reconnect_attempt_ = steady_clock::now();
    
    logger_->Info("Attempting MQTT reconnection", DriverLogCategory::CONNECTION);
    
    // 재연결 시도
    bool success = EstablishConnection();
    
    if (!success) {
        // 재연결 실패, 다시 시도 예약
        std::lock_guard<std::mutex> lock(reconnect_mutex_);
        need_reconnect_ = true;
        reconnect_cv_.notify_one();
        
        logger_->Warn("MQTT reconnection failed, will retry in " + 
                     std::to_string(mqtt_config_.retry_interval) + " seconds",
                     DriverLogCategory::CONNECTION);
    } else {
        logger_->Info("MQTT reconnection successful", DriverLogCategory::CONNECTION);
    }
}

void MqttDriver::CleanupResources() {
    // 클라이언트 정리
    if (client_) {
        try {
            if (client_->is_connected()) {
                client_->disconnect()->wait_for(std::chrono::seconds(5));
            }
        } catch (const mqtt::exception& e) {
            logger_->Error("Error during client cleanup: " + std::string(e.what()),
                          DriverLogCategory::ERROR_HANDLING);
        }
        client_.reset();
    }
    
    // 구독 정보 정리
    {
        std::lock_guard<std::mutex> lock(subscriptions_mutex_);
        subscriptions_.clear();
    }
    
    // 데이터 매핑 정리
    {
        std::lock_guard<std::mutex> lock(data_mapping_mutex_);
        topic_to_datapoints_.clear();
        datapoint_to_topic_.clear();
    }
    
    // 최신 값 정리
    {
        std::lock_guard<std::mutex> lock(values_mutex_);
        latest_values_.clear();
    }
    
    // 발행 큐 정리
    {
        std::lock_guard<std::mutex> lock(publish_queue_mutex_);
        while (!publish_queue_.empty()) {
            auto request = std::move(publish_queue_.front());
            publish_queue_.pop();
            request->promise.set_value(false);  // 실패로 설정
        }
    }
}

// =============================================================================
// 추가 유틸리티 메소드들
// =============================================================================

/**
 * @brief 데이터 포인트와 토픽 매핑 설정
 * @param point 데이터 포인트
 * @param topic MQTT 토픽
 */
void MqttDriver::MapDataPointToTopic(const DataPoint& point, const std::string& topic) {
    std::lock_guard<std::mutex> lock(data_mapping_mutex_);
    
    topic_to_datapoints_[topic].push_back(point);
    datapoint_to_topic_[point.id] = topic;
    
    logger_->Info("Mapped data point '" + point.name + "' to topic '" + topic + "'",
                  DriverLogCategory::GENERAL);
}

/**
 * @brief 데이터 포인트 매핑 제거
 * @param point_id 데이터 포인트 ID
 */
void MqttDriver::UnmapDataPoint(const UUID& point_id) {
    std::lock_guard<std::mutex> lock(data_mapping_mutex_);
    
    auto topic_it = datapoint_to_topic_.find(point_id);
    if (topic_it != datapoint_to_topic_.end()) {
        std::string topic = topic_it->second;
        
        auto points_it = topic_to_datapoints_.find(topic);
        if (points_it != topic_to_datapoints_.end()) {
            auto& points = points_it->second;
            points.erase(
                std::remove_if(points.begin(), points.end(),
                    [&point_id](const DataPoint& p) { return p.id == point_id; }),
                points.end()
            );
            
            if (points.empty()) {
                topic_to_datapoints_.erase(points_it);
            }
        }
        
        datapoint_to_topic_.erase(topic_it);
        
        logger_->Info("Unmapped data point with ID: " + point_id,
                      DriverLogCategory::GENERAL);
    }
}

/**
 * @brief 구독된 토픽 목록 반환
 * @return 구독된 토픽 목록
 */
std::vector<std::string> MqttDriver::GetSubscribedTopics() const {
    std::lock_guard<std::mutex> lock(subscriptions_mutex_);
    
    std::vector<std::string> topics;
    for (const auto& pair : subscriptions_) {
        if (pair.second.subscribed) {
            topics.push_back(pair.first);
        }
    }
    
    return topics;
}

/**
 * @brief 특정 토픽의 구독 통계 반환
 * @param topic 토픽 이름
 * @return 구독 통계 (메시지 수, 마지막 메시지 시간 등)
 */
std::map<std::string, std::string> MqttDriver::GetTopicStatistics(const std::string& topic) const {
    std::lock_guard<std::mutex> lock(subscriptions_mutex_);
    
    std::map<std::string, std::string> stats;
    
    auto it = subscriptions_.find(topic);
    if (it != subscriptions_.end()) {
        const auto& info = it->second;
        
        stats["topic"] = info.topic;
        stats["qos"] = std::to_string(info.qos);
        stats["subscribed"] = info.subscribed ? "true" : "false";
        stats["message_count"] = std::to_string(info.message_count);
        
        if (info.message_count > 0) {
            auto last_msg_time = std::chrono::duration_cast<std::chrono::seconds>(
                info.last_message.time_since_epoch()).count();
            stats["last_message_timestamp"] = std::to_string(last_msg_time);
            
            auto now = system_clock::now();
            auto age_seconds = duration_cast<seconds>(now - info.last_message).count();
            stats["last_message_age_sec"] = std::to_string(age_seconds);
        }
    } else {
        stats["error"] = "Topic not found";
    }
    
    return stats;
}

/**
 * @brief 비동기 메시지 발행
 * @param topic 토픽
 * @param payload 메시지 내용
 * @param qos QoS 레벨
 * @param retained Retained 여부
 * @return 비동기 결과
 */
std::future<bool> MqttDriver::PublishAsync(const std::string& topic, 
                                          const std::string& payload,
                                          int qos, bool retained) {
    auto request = std::make_unique<PublishRequest>(topic, payload, qos, retained);
    auto future = request->promise.get_future();
    
    {
        std::lock_guard<std::mutex> lock(publish_queue_mutex_);
        publish_queue_.push(std::move(request));
    }
    
    publish_queue_cv_.notify_one();
    
    return future;
}
// ✅ message_arrived 콜백 수정 (진단 로깅 추가)
void MqttDriver::message_arrived(mqtt::const_message_ptr msg) {
    auto start_time = std::chrono::steady_clock::now();
    
    try {
        total_messages_received_++;
        total_bytes_received_ += msg->get_payload().length();
        
        // ✅ 진단: 수신 메시지 로깅
        if (diagnostics_enabled_) {
            LogMqttPacket("RECEIVE", msg->get_topic(), msg->get_qos(), 
                         msg->get_payload().length(), true);
        }
        
        ProcessIncomingMessage(msg);
        
        // 기존 로직...
        
    } catch (const std::exception& e) {
        // ✅ 진단: 에러 로깅
        if (diagnostics_enabled_) {
            LogMqttPacket("RECEIVE", msg->get_topic(), msg->get_qos(), 
                         msg->get_payload().length(), false, e.what());
        }
        
        logger_->Error("Message processing error: " + std::string(e.what()),
                      DriverLogCategory::ERROR_HANDLING);
    }
}

// ✅ Publish 메소드 수정 (진단 로깅 추가)
bool MqttDriver::Publish(const std::string& topic, const std::string& payload,
                        int qos, bool retained) {
    auto start_time = std::chrono::steady_clock::now();
    
    // ✅ 진단: 송신 메시지 로깅
    if (diagnostics_enabled_) {
        LogMqttPacket("PUBLISH", topic, qos, payload.length(), true);
    }
    
    try {
        auto msg = mqtt::make_message(topic, payload, qos, retained);
        auto tok = client_->publish(msg, nullptr, *this);
        
        // 기존 로직...
        
        return true;
        
    } catch (const mqtt::exception& e) {
        auto end_time = std::chrono::steady_clock::now();
        auto duration_ms = std::chrono::duration_cast<std::chrono::milliseconds>
                          (end_time - start_time).count();
        
        // ✅ 진단: 에러 로깅
        if (diagnostics_enabled_) {
            LogMqttPacket("PUBLISH", topic, qos, payload.length(), 
                         false, e.what(), duration_ms);
        }
        
        return false;
    }
}

// ✅ MQTT 패킷 로깅 구현
void MqttDriver::LogMqttPacket(const std::string& direction, const std::string& topic,
                              int qos, size_t payload_size, bool success,
                              const std::string& error, double response_time_ms) {
    
    MqttPacketLog log;
    log.direction = direction;
    log.timestamp = std::chrono::system_clock::now();
    log.topic = topic;
    log.qos = qos;
    log.payload_size = payload_size;
    log.success = success;
    log.error_message = error;
    log.response_time_ms = response_time_ms;
    
    // 포인트 이름 조회
    {
        std::lock_guard<std::mutex> lock(mqtt_points_mutex_);
        auto it = mqtt_point_info_map_.find(topic);
        if (it != mqtt_point_info_map_.end()) {
            log.decoded_value = it->second.name + " (" + it->second.unit + ")";
        } else {
            log.decoded_value = "Topic: " + topic;
        }
    }
    
    // 패킷 히스토리에 추가
    {
        std::lock_guard<std::mutex> lock(mqtt_packet_log_mutex_);
        mqtt_packet_history_.push_back(log);
        TrimMqttPacketHistory();
    }
    
    // 콘솔 출력
    if (console_output_enabled_) {
        std::cout << FormatMqttPacketForConsole(log) << std::endl;
    }
    
    // 파일 로깅
    if (packet_logging_enabled_ && log_manager_) {
        std::string log_msg = FormatMqttPacketForFile(log);
        log_manager_->logPacket("mqtt", device_name_, log_msg);
    }
}

// ✅ 콘솔용 포매팅
std::string MqttDriver::FormatMqttPacketForConsole(const MqttPacketLog& log) const {
    std::ostringstream oss;
    
    auto time_t = std::chrono::system_clock::to_time_t(log.timestamp);
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>
             (log.timestamp.time_since_epoch()) % 1000;
    
    oss << "[" << std::put_time(std::localtime(&time_t), "%H:%M:%S") << "."
        << std::setfill('0') << std::setw(3) << ms.count() << "] ";
    
    if (log.direction == "PUBLISH") {
        oss << "📤 PUB -> " << log.topic << " (QoS:" << log.qos << ")"
            << "\n  📦 Size: " << log.payload_size << " bytes"
            << "\n  📊 Point: " << log.decoded_value;
            
    } else if (log.direction == "SUBSCRIBE") {
        oss << "🔔 SUB -> " << log.topic << " (QoS:" << log.qos << ")";
        
    } else { // RECEIVE
        oss << "📥 RCV <- " << log.topic << ": ";
        if (log.success) {
            oss << "✅ SUCCESS"
                << "\n  📦 Size: " << log.payload_size << " bytes"
                << "\n  📊 Point: " << log.decoded_value;
        } else {
            oss << "❌ FAILED: " << log.error_message;
        }
    }
    
    return oss.str();
}
// =============================================================================
// 드라이버 자동 등록
// =============================================================================

// MQTT 드라이버 등록
REGISTER_DRIVER(ProtocolType::MQTT, MqttDriver);