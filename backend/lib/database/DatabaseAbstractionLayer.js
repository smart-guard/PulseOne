// =============================================================================
// backend/lib/database/DatabaseAbstractionLayer.js
// üî• SQLite Ïó∞Í≤∞ Î¨∏Ï†ú Ìï¥Í≤∞ - Î¨¥Ìïú ÎåÄÍ∏∞ ÏàòÏ†ï
// =============================================================================

/**
 * @brief DBÎ≥Ñ SQL Î∞©Ïñ∏(Dialect) Ï≤òÎ¶¨ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
 * C++ ISQLDialectÏôÄ ÎèôÏùºÌïú Íµ¨Ï°∞
 */
class ISQLDialect {
    // Í∏∞Î≥∏ ÌÉÄÏûÖ Î≥ÄÌôò
    getBooleanType() { throw new Error('Not implemented'); }
    getTimestampType() { throw new Error('Not implemented'); }
    getAutoIncrementType() { throw new Error('Not implemented'); }
    getCurrentTimestamp() { throw new Error('Not implemented'); }
    
    // UPSERT ÏøºÎ¶¨ ÏÉùÏÑ±
    buildUpsertQuery(tableName, columns, primaryKeys) { throw new Error('Not implemented'); }
    
    // CREATE TABLE Íµ¨Î¨∏
    adaptCreateTableQuery(baseQuery) { throw new Error('Not implemented'); }
    
    // BOOLEAN Í∞í Î≥ÄÌôò
    formatBooleanValue(value) { throw new Error('Not implemented'); }
    parseBooleanValue(value) { throw new Error('Not implemented'); }
    
    // ÌÖåÏù¥Î∏î Ï°¥Ïû¨ ÌôïÏù∏ ÏøºÎ¶¨
    getTableExistsQuery() { throw new Error('Not implemented'); }
    
    // ÌååÎùºÎØ∏ÌÑ∞ ÌîåÎ†àÏù¥Ïä§ÌôÄÎçî (?, $1, Îì±)
    getParameterPlaceholder(index) { throw new Error('Not implemented'); }
}

/**
 * @brief SQLite Î∞©Ïñ∏ Íµ¨ÌòÑ
 */
class SQLiteDialect extends ISQLDialect {
    getBooleanType() { return 'BOOLEAN'; }
    getTimestampType() { return 'DATETIME'; }
    getAutoIncrementType() { return 'INTEGER PRIMARY KEY AUTOINCREMENT'; }
    getCurrentTimestamp() { return 'CURRENT_TIMESTAMP'; }
    
    buildUpsertQuery(tableName, columns, primaryKeys) {
        const placeholders = columns.map(() => '?').join(', ');
        const updateSet = columns
            .filter(col => !primaryKeys.includes(col))
            .map(col => `${col} = excluded.${col}`)
            .join(', ');
        
        return `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders}) 
                ON CONFLICT (${primaryKeys.join(', ')}) DO UPDATE SET ${updateSet}`;
    }
    
    adaptCreateTableQuery(baseQuery) {
        return baseQuery
            .replace(/SERIAL PRIMARY KEY/g, 'INTEGER PRIMARY KEY AUTOINCREMENT')
            .replace(/BOOLEAN DEFAULT true/g, 'BOOLEAN DEFAULT 1')
            .replace(/BOOLEAN DEFAULT false/g, 'BOOLEAN DEFAULT 0')
            .replace(/TIMESTAMP/g, 'DATETIME');
    }
    
    formatBooleanValue(value) { return value ? '1' : '0'; }
    parseBooleanValue(value) { return value === '1' || value === 'true'; }
    getTableExistsQuery() { return `SELECT name FROM sqlite_master WHERE type='table' AND name = ?`; }
    getParameterPlaceholder(index) { return '?'; }
}

/**
 * @brief PostgreSQL Î∞©Ïñ∏ Íµ¨ÌòÑ
 */
class PostgreSQLDialect extends ISQLDialect {
    getBooleanType() { return 'BOOLEAN'; }
    getTimestampType() { return 'TIMESTAMP'; }
    getAutoIncrementType() { return 'SERIAL PRIMARY KEY'; }
    getCurrentTimestamp() { return 'CURRENT_TIMESTAMP'; }
    
    buildUpsertQuery(tableName, columns, primaryKeys) {
        const placeholders = columns.map((_, i) => `$${i + 1}`).join(', ');
        const updateSet = columns
            .filter(col => !primaryKeys.includes(col))
            .map(col => `${col} = EXCLUDED.${col}`)
            .join(', ');
        
        return `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders}) 
                ON CONFLICT (${primaryKeys.join(', ')}) DO UPDATE SET ${updateSet}`;
    }
    
    adaptCreateTableQuery(baseQuery) {
        return baseQuery; // PostgreSQLÏùÄ ÌëúÏ§Ä SQLÏù¥ÎØÄÎ°ú Î≥ÄÍ≤Ω Î∂àÌïÑÏöî
    }
    
    formatBooleanValue(value) { return value ? 'true' : 'false'; }
    parseBooleanValue(value) { return value === 'true' || value === true; }
    getTableExistsQuery() { return `SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = $1`; }
    getParameterPlaceholder(index) { return `$${index + 1}`; }
}

/**
 * @brief MySQL/MariaDB Î∞©Ïñ∏ Íµ¨ÌòÑ
 */
class MySQLDialect extends ISQLDialect {
    getBooleanType() { return 'BOOLEAN'; }
    getTimestampType() { return 'TIMESTAMP'; }
    getAutoIncrementType() { return 'INT AUTO_INCREMENT PRIMARY KEY'; }
    getCurrentTimestamp() { return 'CURRENT_TIMESTAMP'; }
    
    buildUpsertQuery(tableName, columns, primaryKeys) {
        const placeholders = columns.map(() => '?').join(', ');
        const updateSet = columns
            .filter(col => !primaryKeys.includes(col))
            .map(col => `${col} = VALUES(${col})`)
            .join(', ');
        
        return `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders}) 
                ON DUPLICATE KEY UPDATE ${updateSet}`;
    }
    
    adaptCreateTableQuery(baseQuery) {
        return baseQuery
            .replace(/SERIAL PRIMARY KEY/g, 'INT AUTO_INCREMENT PRIMARY KEY')
            .replace(/DATETIME DEFAULT CURRENT_TIMESTAMP/g, 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP');
    }
    
    formatBooleanValue(value) { return value ? 'true' : 'false'; }
    parseBooleanValue(value) { return value === 'true' || value === true || value === 1; }
    getTableExistsQuery() { return `SELECT table_name FROM information_schema.tables WHERE table_schema = DATABASE() AND table_name = ?`; }
    getParameterPlaceholder(index) { return '?'; }
}

/**
 * @brief MSSQL/SQL Server Î∞©Ïñ∏ Íµ¨ÌòÑ
 */
class MSSQLDialect extends ISQLDialect {
    getBooleanType() { return 'BIT'; }
    getTimestampType() { return 'DATETIME2'; }
    getAutoIncrementType() { return 'INT IDENTITY(1,1) PRIMARY KEY'; }
    getCurrentTimestamp() { return 'GETDATE()'; }
    
    buildUpsertQuery(tableName, columns, primaryKeys) {
        const placeholders = columns.map(() => '?').join(', ');
        const updateSet = columns
            .filter(col => !primaryKeys.includes(col))
            .map(col => `${col} = SOURCE.${col}`)
            .join(', ');
        
        const insertColumns = columns.join(', ');
        const sourceColumns = columns.map(col => `SOURCE.${col}`).join(', ');
        const matchCondition = primaryKeys.map(key => `TARGET.${key} = SOURCE.${key}`).join(' AND ');
        
        return `MERGE ${tableName} AS TARGET
                USING (VALUES (${placeholders})) AS SOURCE (${insertColumns})
                ON ${matchCondition}
                WHEN MATCHED THEN UPDATE SET ${updateSet}
                WHEN NOT MATCHED THEN INSERT (${insertColumns}) VALUES (${sourceColumns});`;
    }
    
    adaptCreateTableQuery(baseQuery) {
        return baseQuery
            .replace(/SERIAL PRIMARY KEY/g, 'INT IDENTITY(1,1) PRIMARY KEY')
            .replace(/BOOLEAN DEFAULT true/g, 'BIT DEFAULT 1')
            .replace(/BOOLEAN DEFAULT false/g, 'BIT DEFAULT 0')
            .replace(/BOOLEAN/g, 'BIT')
            .replace(/DATETIME/g, 'DATETIME2')
            .replace(/CURRENT_TIMESTAMP/g, 'GETDATE()')
            .replace(/TIMESTAMP/g, 'DATETIME2');
    }
    
    formatBooleanValue(value) { return value ? '1' : '0'; }
    parseBooleanValue(value) { return value === '1' || value === 'true' || value === true || value === 1; }
    getTableExistsQuery() { return `SELECT table_name FROM information_schema.tables WHERE table_schema = 'dbo' AND table_name = ?`; }
    getParameterPlaceholder(index) { return '?'; }
}

/**
 * @brief ÌÜµÌï© Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï∂îÏÉÅÌôî Î†àÏù¥Ïñ¥
 * C++Ïùò DatabaseAbstractionLayerÏôÄ ÎèôÏùºÌïú Íµ¨Ï°∞
 */
class DatabaseAbstractionLayer {
    constructor(connections = null) {
        this.connections = connections;
        this.currentDbType = process.env.DATABASE_TYPE || 'SQLITE';
        this.dialect = this.createDialect(this.currentDbType);
        
        console.log(`üîß DatabaseAbstractionLayer: ${this.currentDbType} dialect Ï¥àÍ∏∞ÌôîÎê®`);
    }
    
    /**
     * Ïó∞Í≤∞ Í∞ùÏ≤¥ ÏÑ§Ï†ï
     */
    setConnections(connections) {
        this.connections = connections;
        console.log('‚úÖ DatabaseAbstractionLayer connections ÏÑ§Ï†ïÎê®');
    }
    
    /**
     * DBÎ≥Ñ Dialect ÏÉùÏÑ±
     */
    createDialect(dbType) {
        switch (dbType.toUpperCase()) {
            case 'SQLITE':
                return new SQLiteDialect();
            case 'POSTGRESQL':
            case 'POSTGRES':
                return new PostgreSQLDialect();
            case 'MYSQL':
            case 'MARIADB':
                return new MySQLDialect();
            case 'MSSQL':
            case 'SQLSERVER':
                return new MSSQLDialect();
            default:
                throw new Error(`Unsupported database type: ${dbType}`);
        }
    }
    
    /**
     * ÌòÑÏû¨ ÌôúÏÑ± Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Í∞ÄÏ†∏Ïò§Í∏∞
     */
    getCurrentDatabase() {
        if (!this.connections) {
            throw new Error('Database connections not initialized');
        }

        switch (this.currentDbType.toUpperCase()) {
            case 'POSTGRESQL':
            case 'POSTGRES':
                if (!this.connections.postgres) {
                    throw new Error('PostgreSQL connection not available');
                }
                return { db: this.connections.postgres, type: 'postgresql' };
                
            case 'SQLITE':
                if (!this.connections.sqlite) {
                    throw new Error('SQLite connection not available');
                }
                return { db: this.connections.sqlite, type: 'sqlite' };
                
            case 'MYSQL':
            case 'MARIADB':
                if (!this.connections.mysql) {
                    throw new Error('MySQL connection not available');
                }
                return { db: this.connections.mysql, type: 'mysql' };
                
            case 'MSSQL':
            case 'SQLSERVER':
                if (!this.connections.mssql) {
                    throw new Error('MSSQL connection not available');
                }
                return { db: this.connections.mssql, type: 'mssql' };
                
            default:
                throw new Error(`Unsupported database type: ${this.currentDbType}`);
        }
    }
    
    // =========================================================================
    // üéØ RepositoryÍ∞Ä ÏÇ¨Ïö©Ìï† Í∞ÑÎã®Ìïú Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ (C++Í≥º ÎèôÏùº)
    // =========================================================================
    
    /**
     * SELECT ÏøºÎ¶¨ Ïã§Ìñâ (ÌëúÏ§Ä SQL ‚Üí DBÎ≥Ñ Î∞©Ïñ∏ Î≥ÄÌôò)
     */
    async executeQuery(query, params = []) {
        try {
            const { db, type } = this.getCurrentDatabase();
            
            // ÏøºÎ¶¨Î•º DBÎ≥ÑÎ°ú Ï†ÅÏùë
            const adaptedQuery = this.preprocessQuery(query);
            
            switch (type) {
                case 'postgresql':
                    const pgResult = await db.query(adaptedQuery, params);
                    return pgResult.rows;
                    
                case 'sqlite':
                    // üî• ÌïµÏã¨ ÏàòÏ†ï: SQLite Ïó∞Í≤∞ Í∞ùÏ≤¥Ïùò Ïã§Ï†ú Î©îÏÑúÎìú ÏÇ¨Ïö©
                    if (typeof db.all === 'function') {
                        // SQLite Ïó∞Í≤∞ Í∞ùÏ≤¥Í∞Ä all Î©îÏÑúÎìúÎ•º ÏßÄÏõêÌïòÎäî Í≤ΩÏö∞
                        return await db.all(adaptedQuery, params);
                    } else if (typeof db.query === 'function') {
                        // SQLite Ïó∞Í≤∞ Í∞ùÏ≤¥Í∞Ä query Î©îÏÑúÎìúÎ•º ÏßÄÏõêÌïòÎäî Í≤ΩÏö∞
                        const result = await db.query(adaptedQuery, params);
                        return result.rows || result;
                    } else {
                        throw new Error('SQLite connection does not support query methods');
                    }
                    
                case 'mysql':
                    const [mysqlRows] = await db.execute(adaptedQuery, params);
                    return mysqlRows;
                    
                case 'mssql':
                    const mssqlResult = await db.request();
                    // MSSQL ÌååÎùºÎØ∏ÌÑ∞ Î∞îÏù∏Îî©
                    params.forEach((param, index) => {
                        mssqlResult.input(`param${index}`, param);
                    });
                    const result = await mssqlResult.query(adaptedQuery);
                    return result.recordset;
                    
                default:
                    throw new Error(`Unsupported database type: ${type}`);
            }
            
        } catch (error) {
            console.error('DatabaseAbstractionLayer::executeQuery failed:', error.message);
            console.error('  Query:', query);
            console.error('  Params:', params);
            throw error;
        }
    }
    
    /**
     * INSERT/UPDATE/DELETE Ïã§Ìñâ (ÌëúÏ§Ä SQL ‚Üí DBÎ≥Ñ Î∞©Ïñ∏ Î≥ÄÌôò)
     */
    async executeNonQuery(query, params = []) {
        try {
            const { db, type } = this.getCurrentDatabase();
            
            // ÏøºÎ¶¨Î•º DBÎ≥ÑÎ°ú Ï†ÅÏùë
            const adaptedQuery = this.preprocessQuery(query);
            
            switch (type) {
                case 'postgresql':
                    const pgResult = await db.query(adaptedQuery, params);
                    return pgResult.rowCount > 0;
                    
                case 'sqlite':
                    // üî• ÌïµÏã¨ ÏàòÏ†ï: SQLite Ïó∞Í≤∞ Í∞ùÏ≤¥Ïùò Ïã§Ï†ú Î©îÏÑúÎìú ÏÇ¨Ïö©
                    if (typeof db.run === 'function') {
                        // SQLite Ïó∞Í≤∞ Í∞ùÏ≤¥Í∞Ä run Î©îÏÑúÎìúÎ•º ÏßÄÏõêÌïòÎäî Í≤ΩÏö∞
                        const result = await db.run(adaptedQuery, params);
                        return result.changes > 0;
                    } else if (typeof db.query === 'function') {
                        // SQLite Ïó∞Í≤∞ Í∞ùÏ≤¥Í∞Ä query Î©îÏÑúÎìúÎ•º ÏßÄÏõêÌïòÎäî Í≤ΩÏö∞
                        const result = await db.query(adaptedQuery, params);
                        return result.rowCount > 0 || result.changes > 0;
                    } else {
                        throw new Error('SQLite connection does not support non-query methods');
                    }
                    
                case 'mysql':
                    const [mysqlResult] = await db.execute(adaptedQuery, params);
                    return mysqlResult.affectedRows > 0;
                    
                case 'mssql':
                    const mssqlResult = await db.request();
                    params.forEach((param, index) => {
                        mssqlResult.input(`param${index}`, param);
                    });
                    const result = await mssqlResult.query(adaptedQuery);
                    return result.rowsAffected[0] > 0;
                    
                default:
                    throw new Error(`Unsupported database type: ${type}`);
            }
            
        } catch (error) {
            console.error('DatabaseAbstractionLayer::executeNonQuery failed:', error.message);
            console.error('  Query:', query);
            console.error('  Params:', params);
            throw error;
        }
    }
    
    /**
     * UPSERT ÏøºÎ¶¨ ÏÉùÏÑ± Î∞è Ïã§Ìñâ
     */
    async executeUpsert(tableName, data, primaryKeys) {
        try {
            const columns = Object.keys(data);
            const values = Object.values(data);
            
            const upsertQuery = this.dialect.buildUpsertQuery(tableName, columns, primaryKeys);
            return await this.executeNonQuery(upsertQuery, values);
            
        } catch (error) {
            console.error('DatabaseAbstractionLayer::executeUpsert failed:', error.message);
            return false;
        }
    }
    
    /**
     * CREATE TABLE Ïã§Ìñâ (DBÎ≥Ñ ÏûêÎèô Ï†ÅÏùë)
     */
    async executeCreateTable(createSql) {
        try {
            // 1. ÌÖåÏù¥Î∏î Ïù¥Î¶Ñ Ï∂îÏ∂ú
            const tableName = this.extractTableNameFromCreateSQL(createSql);
            if (!tableName) {
                throw new Error('ÌÖåÏù¥Î∏î Ïù¥Î¶ÑÏùÑ Ï∂îÏ∂úÌï† Ïàò ÏóÜÏùå');
            }
            
            // 2. ÌÖåÏù¥Î∏î Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏
            if (await this.doesTableExist(tableName)) {
                console.log(`‚úÖ ÌÖåÏù¥Î∏î Ïù¥ÎØ∏ Ï°¥Ïû¨: ${tableName}`);
                return true;
            }
            
            // 3. DBÎ≥ÑÎ°ú ÏøºÎ¶¨ Ï†ÅÏùë
            const adaptedQuery = this.dialect.adaptCreateTableQuery(createSql);
            
            // 4. ÌÖåÏù¥Î∏î ÏÉùÏÑ± Ïã§Ìñâ
            console.log(`üìã ÌÖåÏù¥Î∏î ÏÉùÏÑ± ÏãúÎèÑ: ${tableName}`);
            return await this.executeNonQuery(adaptedQuery);
            
        } catch (error) {
            console.error('executeCreateTable failed:', error.message);
            return false;
        }
    }
    
    /**
     * ÌÖåÏù¥Î∏î Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏
     */
    async doesTableExist(tableName) {
        try {
            const query = this.dialect.getTableExistsQuery();
            const result = await this.executeQuery(query, [tableName]);
            return result.length > 0;
            
        } catch (error) {
            console.error('doesTableExist failed:', error.message);
            return false;
        }
    }
    
    /**
     * CREATE TABLE SQLÏóêÏÑú ÌÖåÏù¥Î∏îÎ™Ö Ï∂îÏ∂ú
     */
    extractTableNameFromCreateSQL(createSql) {
        const match = createSql.match(/CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?(\w+)/i);
        return match ? match[1] : null;
    }
    
    /**
     * ÏøºÎ¶¨ Ï†ÑÏ≤òÎ¶¨ (Ï£ºÏÑù Ï†úÍ±∞, Í≥µÎ∞± Ï†ïÎ¶¨ Îì±)
     */
    preprocessQuery(query) {
        return query
            .replace(/--[^\r\n]*/g, '')  // SQL Ï£ºÏÑù Ï†úÍ±∞
            .replace(/\s+/g, ' ')        // Ïó¨Îü¨ Í≥µÎ∞±ÏùÑ ÌïòÎÇòÎ°ú
            .trim();                     // ÏïûÎí§ Í≥µÎ∞± Ï†úÍ±∞
    }
    
    /**
     * BOOLEAN Í∞í Ìè¨Îß∑ÌåÖ (DBÎ≥Ñ)
     */
    formatBoolean(value) {
        return this.dialect.formatBooleanValue(value);
    }
    
    /**
     * BOOLEAN Í∞í ÌååÏã± (DBÎ≥Ñ)
     */
    parseBoolean(value) {
        return this.dialect.parseBooleanValue(value);
    }
    
    /**
     * ÌòÑÏû¨ ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Í∞ÄÏ†∏Ïò§Í∏∞ (DBÎ≥Ñ)
     */
    getCurrentTimestamp() {
        return this.dialect.getCurrentTimestamp();
    }
    
    /**
     * ÌòÑÏû¨ DB ÌÉÄÏûÖ Î∞òÌôò
     */
    getCurrentDbType() {
        return this.currentDbType;
    }

    /**
     * üî• ÎîîÎ≤ÑÍπÖÏùÑ ÏúÑÌïú Ïó∞Í≤∞ Ï†ïÎ≥¥ Ï∂úÎ†•
     */
    debugConnectionInfo() {
        try {
            const { db, type } = this.getCurrentDatabase();
            console.log(`üîç Ïó∞Í≤∞ ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥:
  ÌÉÄÏûÖ: ${type}
  Ïó∞Í≤∞ Í∞ùÏ≤¥ Ï°¥Ïû¨: ${!!db}
  ÏßÄÏõê Î©îÏÑúÎìú: ${Object.getOwnPropertyNames(Object.getPrototypeOf(db)).filter(name => typeof db[name] === 'function').join(', ')}`);
        } catch (error) {
            console.error('üîç Ïó∞Í≤∞ ÎîîÎ≤ÑÍ∑∏ Ïã§Ìå®:', error.message);
        }
    }
}

module.exports = {
    DatabaseAbstractionLayer,
    SQLiteDialect,
    PostgreSQLDialect, 
    MySQLDialect,
    MSSQLDialect
};