// ===========================================================================
// backend/lib/connection/redis.js - redis.env ÏÑ§Ï†ï Í∏∞Î∞ò
// ===========================================================================
const redis = require('redis');
const ConfigManager = require('../config/ConfigManager');

const config = ConfigManager.getInstance();

class RedisManager {
    constructor() {
        this.client = null;
        this.isConnecting = false;
        this.isConnected = false;
        
        // redis.env ÌååÏùºÏùò ÌôòÍ≤ΩÎ≥ÄÏàò Í∏∞Î∞ò ÏÑ§Ï†ï
        this.redisConfig = {
            enabled: config.getBoolean('REDIS_PRIMARY_ENABLED', false),
            host: config.get('REDIS_PRIMARY_HOST', 'localhost'),
            port: config.getNumber('REDIS_PRIMARY_PORT', 6379),
            password: config.get('REDIS_PRIMARY_PASSWORD', ''),
            db: config.getNumber('REDIS_PRIMARY_DB', 0),
            timeout: config.getNumber('REDIS_PRIMARY_TIMEOUT_MS', 5000),
            connectTimeout: config.getNumber('REDIS_PRIMARY_CONNECT_TIMEOUT_MS', 3000),
            
            // Ïó∞Í≤∞ ÌíÄ ÏÑ§Ï†ï
            poolSize: config.getNumber('REDIS_POOL_SIZE', 5),
            poolMaxIdle: config.getNumber('REDIS_POOL_MAX_IDLE', 3),
            poolMaxActive: config.getNumber('REDIS_POOL_MAX_ACTIVE', 10),
            poolMaxWait: config.getNumber('REDIS_POOL_MAX_WAIT_MS', 5000),
            connectionTimeout: config.getNumber('REDIS_CONNECTION_TIMEOUT_MS', 30000),
            commandTimeout: config.getNumber('REDIS_COMMAND_TIMEOUT_MS', 10000),
            tcpKeepAlive: config.getBoolean('REDIS_TCP_KEEPALIVE', true),
            
            // Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏÑ§Ï†ï (Ï†ëÎëêÏÇ¨ ÏóÜÏùå)
            keyPrefix: '', // Ï†ëÎëêÏÇ¨ ÏÇ¨Ïö© ÏïàÌï®
            defaultExpiry: config.getNumber('REDIS_DEFAULT_EXPIRY_S', 3600),
            maxMemoryPolicy: config.get('REDIS_MAX_MEMORY_POLICY', 'allkeys-lru'),
            
            // Ïó∞Í≤∞ Í¥ÄÎ¶¨
            autoPing: config.getBoolean('REDIS_AUTO_PING', true),
            pingInterval: config.getNumber('REDIS_PING_INTERVAL_S', 30) * 1000
        };
        
        console.log('üîß Redis ÏÑ§Ï†ï Î°úÎìú:', {
            enabled: this.redisConfig.enabled,
            host: this.redisConfig.host,
            port: this.redisConfig.port,
            db: this.redisConfig.db,
            hasPassword: !!this.redisConfig.password,
            poolSize: this.redisConfig.poolSize,
            autoPing: this.redisConfig.autoPing
        });
    }

    async getClient() {
        if (!this.redisConfig.enabled) {
            console.log('‚ö†Ô∏è Redis ÎπÑÌôúÏÑ±ÌôîÎê® (REDIS_PRIMARY_ENABLED=false)');
            throw new Error('RedisÍ∞Ä ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§');
        }

        if (this.client && this.isConnected) {
            return this.client;
        }

        if (this.isConnecting) {
            return await this.waitForConnection();
        }

        return await this.connect();
    }

    async connect() {
        if (this.isConnecting) {
            return await this.waitForConnection();
        }

        this.isConnecting = true;

        try {
            console.log(`üîó Redis Ïó∞Í≤∞ ÏãúÎèÑ: ${this.redisConfig.host}:${this.redisConfig.port}`);

            // Redis v4 ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ï†ï
            const clientConfig = {
                socket: {
                    host: this.redisConfig.host,
                    port: this.redisConfig.port,
                    connectTimeout: this.redisConfig.connectTimeout,
                    commandTimeout: this.redisConfig.commandTimeout,
                    keepAlive: this.redisConfig.tcpKeepAlive,
                    reconnectStrategy: (retries) => {
                        if (retries > 3) {
                            console.error('‚ùå Redis Ïû¨Ïó∞Í≤∞ ÏµúÎåÄ ÏãúÎèÑ ÌöüÏàò Ï¥àÍ≥º');
                            return false;
                        }
                        const delay = Math.min(retries * 1000, 5000);
                        console.log(`üîÑ ${delay}ms ÌõÑ Redis Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ (${retries}/3)`);
                        return delay;
                    }
                },
                // ÎπÑÎ∞ÄÎ≤àÌò∏ ÏÑ§Ï†ï
                password: this.redisConfig.password || undefined,
                // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ†ÌÉù
                database: this.redisConfig.db
            };

            this.client = redis.createClient(clientConfig);
            this.setupEventHandlers();

            // Ïó∞Í≤∞ ÏãúÎèÑ
            await this.client.connect();

            // Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
            const pong = await this.client.ping();
            if (pong !== 'PONG') {
                throw new Error('Redis PING ÌÖåÏä§Ìä∏ Ïã§Ìå®');
            }

            this.isConnected = true;
            this.isConnecting = false;

            console.log('‚úÖ Redis Ïó∞Í≤∞ ÏÑ±Í≥µ');
            
            // Auto ping ÏÑ§Ï†ï
            if (this.redisConfig.autoPing) {
                this.startAutoPing();
            }

            return this.client;

        } catch (error) {
            this.isConnecting = false;
            this.isConnected = false;
            
            console.error('‚ùå Redis Ïó∞Í≤∞ Ïã§Ìå®:', error.message);
            
            if (this.client) {
                try {
                    await this.client.disconnect();
                } catch (disconnectError) {
                    // Î¨¥Ïãú
                }
                this.client = null;
            }
            
            throw new Error(`Redis Ïó∞Í≤∞ Ïã§Ìå®: ${error.message}`);
        }
    }

    setupEventHandlers() {
        if (!this.client) return;

        this.client.on('error', (err) => {
            console.error('‚ùå Redis Ïò§Î•ò:', err.message);
            this.isConnected = false;
        });

        this.client.on('connect', () => {
            console.log('üîÑ Redis ÏÜåÏºì Ïó∞Í≤∞Îê®');
        });

        this.client.on('ready', () => {
            console.log('‚úÖ Redis ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï§ÄÎπÑ ÏôÑÎ£å');
            this.isConnected = true;
        });

        this.client.on('disconnect', () => {
            console.warn('‚ö†Ô∏è Redis Ïó∞Í≤∞ Ìï¥Ï†úÎê®');
            this.isConnected = false;
            this.stopAutoPing();
        });

        this.client.on('reconnecting', () => {
            console.log('üîÑ Redis Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ Ï§ë...');
        });

        this.client.on('end', () => {
            console.log('üì¥ Redis Ïó∞Í≤∞ Ï¢ÖÎ£åÎê®');
            this.isConnected = false;
            this.stopAutoPing();
        });
    }

    startAutoPing() {
        if (this.pingIntervalId) {
            clearInterval(this.pingIntervalId);
        }

        this.pingIntervalId = setInterval(async () => {
            try {
                if (this.client && this.isConnected) {
                    await this.client.ping();
                    console.log('üèì Redis Auto-ping ÏÑ±Í≥µ');
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Redis Auto-ping Ïã§Ìå®:', error.message);
            }
        }, this.redisConfig.pingInterval);

        console.log(`üèì Redis Auto-ping ÏãúÏûë (${this.redisConfig.pingInterval / 1000}Ï¥à Í∞ÑÍ≤©)`);
    }

    stopAutoPing() {
        if (this.pingIntervalId) {
            clearInterval(this.pingIntervalId);
            this.pingIntervalId = null;
            console.log('üèì Redis Auto-ping Ï§ëÏßÄ');
        }
    }

    async waitForConnection() {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Redis Ïó∞Í≤∞ ÎåÄÍ∏∞ ÏãúÍ∞Ñ Ï¥àÍ≥º'));
            }, this.redisConfig.connectTimeout);

            const checkConnection = () => {
                if (!this.isConnecting) {
                    clearTimeout(timeout);
                    if (this.client && this.isConnected) {
                        resolve(this.client);
                    } else {
                        reject(new Error('Redis Ïó∞Í≤∞ Ïã§Ìå®'));
                    }
                } else {
                    setTimeout(checkConnection, 100);
                }
            };
            checkConnection();
        });
    }

    async close() {
        this.stopAutoPing();
        
        if (this.client && this.isConnected) {
            try {
                await this.client.quit();
                console.log('üì¥ Redis Ïó∞Í≤∞ Ï†ïÏÉÅ Ï¢ÖÎ£å');
            } catch (error) {
                console.error('‚ùå Redis Ï¢ÖÎ£å Ïò§Î•ò:', error.message);
                try {
                    await this.client.disconnect();
                } catch (disconnectError) {
                    // Î¨¥Ïãú
                }
            }
        }
        this.client = null;
        this.isConnected = false;
        this.isConnecting = false;
    }

    async healthCheck() {
        try {
            if (!this.client || !this.isConnected) {
                return { status: 'disconnected', error: 'No connection' };
            }

            const start = Date.now();
            const pong = await this.client.ping();
            const latency = Date.now() - start;

            const info = await this.client.info('memory');
            const usedMemory = info.match(/used_memory_human:([^\r\n]+)/)?.[1];

            return {
                status: 'healthy',
                latency: `${latency}ms`,
                response: pong,
                memory: usedMemory,
                uptime: this.isConnected ? 'connected' : 'disconnected',
                config: {
                    host: this.redisConfig.host,
                    port: this.redisConfig.port,
                    db: this.redisConfig.db
                }
            };
        } catch (error) {
            return {
                status: 'unhealthy',
                error: error.message
            };
        }
    }

    getStatus() {
        return {
            enabled: this.redisConfig.enabled,
            connected: this.isConnected,
            connecting: this.isConnecting,
            client: !!this.client,
            config: {
                host: this.redisConfig.host,
                port: this.redisConfig.port,
                db: this.redisConfig.db,
                poolSize: this.redisConfig.poolSize,
                autoPing: this.redisConfig.autoPing,
                keyPrefix: this.redisConfig.keyPrefix || '(ÏóÜÏùå)'
            }
        };
    }
}

// Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§
let redisManager;

function getRedisManager() {
    if (!redisManager) {
        redisManager = new RedisManager();
    }
    return redisManager;
}

// realtime.jsÏóêÏÑú ÏÇ¨Ïö©Ìï† getRedisClient Ìï®Ïàò
async function getRedisClient() {
    try {
        const manager = getRedisManager();
        const client = await manager.getClient();
        
        if (!client) {
            throw new Error('Redis ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä nullÏûÖÎãàÎã§');
        }
        
        if (!client.isReady) {
            throw new Error('Redis ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä Ï§ÄÎπÑÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§');
        }
        
        return client;
    } catch (error) {
        console.error('‚ùå getRedisClient Ïã§Ìå®:', error.message);
        return null;
    }
}

// Í∏∞Ï°¥ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌïú ÌîÑÎ°ùÏãú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏
const redisProxy = new Proxy({}, {
    get(target, prop) {
        if (prop === 'getManager') {
            return getRedisManager;
        }
        
        return async function(...args) {
            const manager = getRedisManager();
            const client = await manager.getClient();
            
            if (client && typeof client[prop] === 'function') {
                return await client[prop](...args);
            } else {
                console.warn(`‚ö†Ô∏è Redis Î©îÏÑúÎìú ${prop} Ìò∏Ï∂ú Ïã§Ìå®`);
                return null;
            }
        };
    }
});

// exports
module.exports = {
    ...redisProxy,
    getRedisClient,
    getRedisManager
};


