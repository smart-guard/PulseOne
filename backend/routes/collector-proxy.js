// =============================================================================
// backend/routes/collector-proxy.js
// Collector API ÌîÑÎ°ùÏãú ÎùºÏö∞Ìä∏ (Î™®Îì† Frontend ‚Üí Collector ÏöîÏ≤≠ Ï≤òÎ¶¨)
// =============================================================================

const express = require('express');
const router = express.Router();
const { getInstance: getCollectorProxy } = require('../lib/services/CollectorProxyService');

// ÎØ∏Îì§Ïõ®Ïñ¥: Collector Ïó∞Í≤∞ ÌôïÏù∏
const checkCollectorConnection = async (req, res, next) => {
  try {
    const proxy = getCollectorProxy();
    
    if (!proxy.isCollectorHealthy()) {
      // Ïó∞Í≤∞ ÏÉÅÌÉú Ï≤¥ÌÅ¨ ÏãúÎèÑ
      try {
        await proxy.healthCheck();
      } catch (error) {
        return res.status(503).json({
          success: false,
          error: 'Collector service is unavailable',
          details: 'Collector ÏÑúÎπÑÏä§Ïóê Ïó∞Í≤∞Ìï† Ïàò ÏóÜÏäµÎãàÎã§. ÏÑúÎπÑÏä§Í∞Ä Ïã§Ìñâ Ï§ëÏù∏ÏßÄ ÌôïÏù∏ÌïòÏÑ∏Ïöî.',
          lastHealthCheck: proxy.getLastHealthCheck(),
          collectorConfig: proxy.getCollectorConfig()
        });
      }
    }
    
    next();
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to check collector connection',
      details: error.message
    });
  }
};

// Í≥µÌÜµ ÏóêÎü¨ Ìï∏Îì§Îü¨
const handleProxyError = (error, req, res) => {
  console.error(`‚ùå Collector Proxy Error [${req.method} ${req.originalUrl}]:`, error);
  
  if (error.name === 'CollectorProxyError') {
    const statusCode = error.status || 500;
    
    res.status(statusCode).json({
      success: false,
      error: `Collector API Error: ${error.operation}`,
      details: error.collectorError || error.message,
      context: error.context,
      collectorResponse: error.collectorResponse
    });
  } else {
    res.status(500).json({
      success: false,
      error: 'Proxy communication failed',
      details: error.message
    });
  }
};

// =============================================================================
// üî• 1. ÎîîÎ∞îÏù¥Ïä§ Ï†úÏñ¥ API (ÏµúÏö∞ÏÑ† Íµ¨ÌòÑ)
// =============================================================================

/**
 * POST /api/collector/devices/:deviceId/start
 * ÎîîÎ∞îÏù¥Ïä§ ÏõåÏª§ ÏãúÏûë
 */
router.post('/devices/:deviceId/start', checkCollectorConnection, async (req, res) => {
  try {
    const { deviceId } = req.params;
    const { force_restart, ...options } = req.body;
    
    console.log(`üöÄ Starting device worker: ${deviceId}`);
    
    const proxy = getCollectorProxy();
    const result = await proxy.startDevice(deviceId, { forceRestart: force_restart, ...options });
    
    res.json({
      success: true,
      message: `Device ${deviceId} started successfully`,
      data: result.data,
      device_id: deviceId,
      action: 'start',
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * POST /api/collector/devices/:deviceId/stop
 * ÎîîÎ∞îÏù¥Ïä§ ÏõåÏª§ Ï§ëÏßÄ
 */
router.post('/devices/:deviceId/stop', checkCollectorConnection, async (req, res) => {
  try {
    const { deviceId } = req.params;
    const { graceful, ...options } = req.body;
    
    console.log(`üõë Stopping device worker: ${deviceId}`);
    
    const proxy = getCollectorProxy();
    const result = await proxy.stopDevice(deviceId, { graceful, ...options });
    
    res.json({
      success: true,
      message: `Device ${deviceId} stopped successfully`,
      data: result.data,
      device_id: deviceId,
      action: 'stop',
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * POST /api/collector/devices/:deviceId/pause
 * ÎîîÎ∞îÏù¥Ïä§ ÏõåÏª§ ÏùºÏãúÏ†ïÏßÄ
 */
router.post('/devices/:deviceId/pause', checkCollectorConnection, async (req, res) => {
  try {
    const { deviceId } = req.params;
    
    console.log(`‚è∏Ô∏è Pausing device worker: ${deviceId}`);
    
    const proxy = getCollectorProxy();
    const result = await proxy.pauseDevice(deviceId);
    
    res.json({
      success: true,
      message: `Device ${deviceId} paused successfully`,
      data: result.data,
      device_id: deviceId,
      action: 'pause',
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * POST /api/collector/devices/:deviceId/resume
 * ÎîîÎ∞îÏù¥Ïä§ ÏõåÏª§ Ïû¨Í∞ú
 */
router.post('/devices/:deviceId/resume', checkCollectorConnection, async (req, res) => {
  try {
    const { deviceId } = req.params;
    
    console.log(`‚ñ∂Ô∏è Resuming device worker: ${deviceId}`);
    
    const proxy = getCollectorProxy();
    const result = await proxy.resumeDevice(deviceId);
    
    res.json({
      success: true,
      message: `Device ${deviceId} resumed successfully`,
      data: result.data,
      device_id: deviceId,
      action: 'resume',
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * POST /api/collector/devices/:deviceId/restart
 * ÎîîÎ∞îÏù¥Ïä§ ÏõåÏª§ Ïû¨ÏãúÏûë
 */
router.post('/devices/:deviceId/restart', checkCollectorConnection, async (req, res) => {
  try {
    const { deviceId } = req.params;
    const { wait, ...options } = req.body;
    
    console.log(`üîÑ Restarting device worker: ${deviceId}`);
    
    const proxy = getCollectorProxy();
    const result = await proxy.restartDevice(deviceId, { wait, ...options });
    
    res.json({
      success: true,
      message: `Device ${deviceId} restarted successfully`,
      data: result.data,
      device_id: deviceId,
      action: 'restart',
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * GET /api/collector/devices/:deviceId/status
 * ÎîîÎ∞îÏù¥Ïä§ Ïã§ÏãúÍ∞Ñ ÏÉÅÌÉú Ï°∞Ìöå
 */
router.get('/devices/:deviceId/status', checkCollectorConnection, async (req, res) => {
  try {
    const { deviceId } = req.params;
    
    const proxy = getCollectorProxy();
    const result = await proxy.getDeviceStatus(deviceId);
    
    res.json({
      success: true,
      data: result.data,
      device_id: deviceId,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

// =============================================================================
// üî• 2. ÌïòÎìúÏõ®Ïñ¥ Ï†úÏñ¥ API
// =============================================================================

/**
 * POST /api/collector/devices/:deviceId/digital/:outputId/control
 * ÎîîÏßÄÌÑ∏ Ï∂úÎ†• Ï†úÏñ¥ (Î¶¥Î†àÏù¥, ÏÜîÎ†àÎÖ∏Ïù¥Îìú Îì±)
 */
router.post('/devices/:deviceId/digital/:outputId/control', checkCollectorConnection, async (req, res) => {
  try {
    const { deviceId, outputId } = req.params;
    const { state, duration, force } = req.body;
    
    if (state === undefined || state === null) {
      return res.status(400).json({
        success: false,
        error: 'Missing required parameter: state',
        details: 'state must be true or false'
      });
    }
    
    console.log(`üîå Digital control: Device ${deviceId}, Output ${outputId}, State: ${state}`);
    
    const proxy = getCollectorProxy();
    const result = await proxy.controlDigitalOutput(deviceId, outputId, state, { duration, force });
    
    res.json({
      success: true,
      message: `Digital output ${outputId} set to ${state}`,
      data: result.data,
      device_id: deviceId,
      output_id: outputId,
      state: Boolean(state),
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * POST /api/collector/devices/:deviceId/analog/:outputId/control
 * ÏïÑÎÇ†Î°úÍ∑∏ Ï∂úÎ†• Ï†úÏñ¥ (4-20mA, 0-10V Îì±)
 */
router.post('/devices/:deviceId/analog/:outputId/control', checkCollectorConnection, async (req, res) => {
  try {
    const { deviceId, outputId } = req.params;
    const { value, unit, ramp_time } = req.body;
    
    if (value === undefined || value === null) {
      return res.status(400).json({
        success: false,
        error: 'Missing required parameter: value',
        details: 'value must be a number'
      });
    }
    
    console.log(`üìä Analog control: Device ${deviceId}, Output ${outputId}, Value: ${value}`);
    
    const proxy = getCollectorProxy();
    const result = await proxy.controlAnalogOutput(deviceId, outputId, value, { unit, rampTime: ramp_time });
    
    res.json({
      success: true,
      message: `Analog output ${outputId} set to ${value}${unit ? ' ' + unit : ''}`,
      data: result.data,
      device_id: deviceId,
      output_id: outputId,
      value: Number(value),
      unit: unit || null,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * POST /api/collector/devices/:deviceId/parameters/:parameterId/set
 * ÎîîÎ∞îÏù¥Ïä§ ÌååÎùºÎØ∏ÌÑ∞ ÏÑ§Ï†ï
 */
router.post('/devices/:deviceId/parameters/:parameterId/set', checkCollectorConnection, async (req, res) => {
  try {
    const { deviceId, parameterId } = req.params;
    const { value, data_type, validate } = req.body;
    
    if (value === undefined || value === null) {
      return res.status(400).json({
        success: false,
        error: 'Missing required parameter: value'
      });
    }
    
    console.log(`‚öôÔ∏è Parameter set: Device ${deviceId}, Parameter ${parameterId}, Value: ${value}`);
    
    const proxy = getCollectorProxy();
    const result = await proxy.setParameter(deviceId, parameterId, value, { dataType: data_type, validate });
    
    res.json({
      success: true,
      message: `Parameter ${parameterId} set to ${value}`,
      data: result.data,
      device_id: deviceId,
      parameter_id: parameterId,
      value,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

// =============================================================================
// üî• 3. Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ API
// =============================================================================

/**
 * GET /api/collector/devices/:deviceId/data/current
 * ÎîîÎ∞îÏù¥Ïä§ ÌòÑÏû¨ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
 */
router.get('/devices/:deviceId/data/current', checkCollectorConnection, async (req, res) => {
  try {
    const { deviceId } = req.params;
    const { point_ids } = req.query;
    
    const pointIds = point_ids ? point_ids.split(',').map(id => id.trim()) : [];
    
    const proxy = getCollectorProxy();
    const result = await proxy.getCurrentData(deviceId, pointIds);
    
    res.json({
      success: true,
      data: result.data,
      device_id: deviceId,
      point_count: result.data?.points?.length || 0,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * GET /api/collector/alarms/active
 * ÌôúÏÑ± ÏïåÎûå Î™©Î°ù Ï°∞Ìöå
 */
router.get('/alarms/active', checkCollectorConnection, async (req, res) => {
  try {
    const { severity, device_id, limit, acknowledged } = req.query;
    
    const options = {
      severity,
      deviceId: device_id,
      limit: limit ? parseInt(limit) : 50,
      acknowledged: acknowledged === 'true'
    };
    
    const proxy = getCollectorProxy();
    const result = await proxy.getActiveAlarms(options);
    
    res.json({
      success: true,
      data: result.data,
      query_options: options,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * POST /api/collector/alarms/:alarmId/acknowledge
 * ÏïåÎûå ÌôïÏù∏
 */
router.post('/alarms/:alarmId/acknowledge', checkCollectorConnection, async (req, res) => {
  try {
    const { alarmId } = req.params;
    const { user_id, comment } = req.body;
    
    // ÏÇ¨Ïö©Ïûê IDÎäî ÏÑ∏ÏÖòÏóêÏÑú Í∞ÄÏ†∏Ïò§Í±∞ÎÇò bodyÏóêÏÑú Î∞õÏùå
    const userId = user_id || req.user?.id || 1; // Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
    
    console.log(`‚úÖ Acknowledging alarm ${alarmId} by user ${userId}`);
    
    const proxy = getCollectorProxy();
    const result = await proxy.acknowledgeAlarm(alarmId, userId, comment || '');
    
    res.json({
      success: true,
      message: 'Alarm acknowledged successfully',
      data: result.data,
      alarm_id: alarmId,
      user_id: userId,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * POST /api/collector/alarms/:alarmId/clear
 * ÏïåÎûå ÌÅ¥Î¶¨Ïñ¥
 */
router.post('/alarms/:alarmId/clear', checkCollectorConnection, async (req, res) => {
  try {
    const { alarmId } = req.params;
    const { user_id, comment } = req.body;
    
    const userId = user_id || req.user?.id || 1;
    
    console.log(`üîÑ Clearing alarm ${alarmId} by user ${userId}`);
    
    const proxy = getCollectorProxy();
    const result = await proxy.clearAlarm(alarmId, userId, comment || '');
    
    res.json({
      success: true,
      message: 'Alarm cleared successfully',
      data: result.data,
      alarm_id: alarmId,
      user_id: userId,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

// =============================================================================
// üî• 4. ÏÑ§Ï†ï ÎèôÍ∏∞Ìôî API
// =============================================================================

/**
 * POST /api/collector/devices/:deviceId/config/reload
 * ÎîîÎ∞îÏù¥Ïä§ ÏÑ§Ï†ï Ïû¨Î°úÎìú
 */
router.post('/devices/:deviceId/config/reload', checkCollectorConnection, async (req, res) => {
  try {
    const { deviceId } = req.params;
    
    console.log(`üîÑ Reloading config for device ${deviceId}`);
    
    const proxy = getCollectorProxy();
    const result = await proxy.reloadDeviceConfig(deviceId);
    
    res.json({
      success: true,
      message: `Configuration reloaded for device ${deviceId}`,
      data: result.data,
      device_id: deviceId,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * POST /api/collector/config/reload
 * Ï†ÑÏ≤¥ ÏÑ§Ï†ï Ïû¨Î°úÎìú
 */
router.post('/config/reload', checkCollectorConnection, async (req, res) => {
  try {
    console.log('üîÑ Reloading all configurations');
    
    const proxy = getCollectorProxy();
    const result = await proxy.reloadAllConfigs();
    
    res.json({
      success: true,
      message: 'All configurations reloaded successfully',
      data: result.data,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * POST /api/collector/devices/:deviceId/sync
 * ÎîîÎ∞îÏù¥Ïä§ ÏÑ§Ï†ï ÎèôÍ∏∞Ìôî
 */
router.post('/devices/:deviceId/sync', checkCollectorConnection, async (req, res) => {
  try {
    const { deviceId } = req.params;
    const settings = req.body;
    
    console.log(`üîÑ Syncing settings for device ${deviceId}`);
    
    const proxy = getCollectorProxy();
    const result = await proxy.syncDeviceSettings(deviceId, settings);
    
    res.json({
      success: true,
      message: `Settings synchronized for device ${deviceId}`,
      data: result.data,
      device_id: deviceId,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * POST /api/collector/config/notify-change
 * ÏÑ§Ï†ï Î≥ÄÍ≤Ω ÏïåÎ¶º
 */
router.post('/config/notify-change', checkCollectorConnection, async (req, res) => {
  try {
    const { type, entity_id, changes } = req.body;
    
    if (!type || !entity_id) {
      return res.status(400).json({
        success: false,
        error: 'Missing required parameters: type, entity_id'
      });
    }
    
    console.log(`üîî Notifying config change: ${type} ${entity_id}`);
    
    const proxy = getCollectorProxy();
    const result = await proxy.notifyConfigChange(type, entity_id, changes || {});
    
    res.json({
      success: true,
      message: 'Configuration change notification sent',
      data: result.data,
      change_type: type,
      entity_id,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

// =============================================================================
// üî• 5. ÏãúÏä§ÌÖú Í¥ÄÎ¶¨ API
// =============================================================================

/**
 * GET /api/collector/statistics
 * Collector ÌÜµÍ≥Ñ Ï†ïÎ≥¥ Ï°∞Ìöå
 */
router.get('/statistics', checkCollectorConnection, async (req, res) => {
  try {
    const proxy = getCollectorProxy();
    const result = await proxy.getSystemStatistics();
    
    res.json({
      success: true,
      data: result.data,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * GET /api/collector/workers/status
 * ÏõåÏª§ ÏÉÅÌÉú Ï°∞Ìöå
 */
router.get('/workers/status', checkCollectorConnection, async (req, res) => {
  try {
    const proxy = getCollectorProxy();
    const result = await proxy.getWorkerStatus();
    
    res.json({
      success: true,
      data: result.data,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    handleProxyError(error, req, res);
  }
});

/**
 * GET /api/collector/health
 * Collector Ìó¨Ïä§ Ï≤¥ÌÅ¨
 */
router.get('/health', async (req, res) => {
  try {
    const proxy = getCollectorProxy();
    const result = await proxy.healthCheck();
    
    res.json({
      success: true,
      status: 'healthy',
      data: result.data,
      last_check: result.timestamp,
      collector_config: proxy.getCollectorConfig()
    });
    
  } catch (error) {
    res.status(503).json({
      success: false,
      status: 'unhealthy',
      error: 'Collector health check failed',
      details: error.message,
      last_healthy_check: getCollectorProxy().getLastHealthCheck(),
      collector_config: getCollectorProxy().getCollectorConfig()
    });
  }
});

module.exports = router;