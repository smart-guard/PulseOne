const express = require('express');
const router = express.Router();
const os = require('os');
const fs = require('fs');
const { promisify } = require('util');

// ‚úÖ ConfigManager import Ï∂îÍ∞Ä
const ConfigManager = require('../lib/config/ConfigManager');

// =============================================================================
// üìä ÏãúÏä§ÌÖú Î©îÌä∏Î¶≠ Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
// =============================================================================

/**
 * CPU ÏÇ¨Ïö©Î•† Í≥ÑÏÇ∞ (1Ï¥àÍ∞Ñ Ï∏°Ï†ï)
 */
function getCPUUsage() {
    return new Promise((resolve) => {
        const startMeasure = os.cpus();
        const startTime = Date.now();
        
        setTimeout(() => {
            const endMeasure = os.cpus();
            const endTime = Date.now();
            
            let totalIdle = 0;
            let totalTick = 0;
            
            for (let i = 0; i < startMeasure.length; i++) {
                const startCpu = startMeasure[i];
                const endCpu = endMeasure[i];
                
                const startTotal = Object.values(startCpu.times).reduce((acc, time) => acc + time, 0);
                const endTotal = Object.values(endCpu.times).reduce((acc, time) => acc + time, 0);
                
                const idleDiff = endCpu.times.idle - startCpu.times.idle;
                const totalDiff = endTotal - startTotal;
                
                totalIdle += idleDiff;
                totalTick += totalDiff;
            }
            
            const usage = Math.round(100 - (100 * totalIdle / totalTick));
            resolve(Math.max(0, Math.min(100, usage))); // 0-100% Î≤îÏúÑÎ°ú Ï†úÌïú
        }, 1000);
    });
}

/**
 * ÎîîÏä§ÌÅ¨ ÏÇ¨Ïö©Î•† Í≥ÑÏÇ∞ (Windows/Linux Ìò∏Ìôò)
 */
async function getDiskUsage() {
    try {
        if (process.platform === 'win32') {
            // Windows
            const { execSync } = require('child_process');
            const output = execSync('wmic logicaldisk get size,freespace,caption', { encoding: 'utf8' });
            const lines = output.split('\n').filter(line => line.includes(':'));
            
            if (lines.length > 0) {
                const parts = lines[0].trim().split(/\s+/);
                const freeSpace = parseInt(parts[1]);
                const totalSpace = parseInt(parts[2]);
                const usedSpace = totalSpace - freeSpace;
                
                return {
                    total: Math.round(totalSpace / (1024 * 1024 * 1024)), // GB
                    used: Math.round(usedSpace / (1024 * 1024 * 1024)),   // GB
                    free: Math.round(freeSpace / (1024 * 1024 * 1024)),   // GB
                    usage: Math.round((usedSpace / totalSpace) * 100)     // %
                };
            }
        } else {
            // Linux/macOS
            const { execSync } = require('child_process');
            const output = execSync('df -h /', { encoding: 'utf8' });
            const lines = output.split('\n');
            
            if (lines.length > 1) {
                const parts = lines[1].split(/\s+/);
                const totalGB = parseFloat(parts[1].replace('G', ''));
                const usedGB = parseFloat(parts[2].replace('G', ''));
                const freeGB = parseFloat(parts[3].replace('G', ''));
                const usagePercent = parseInt(parts[4].replace('%', ''));
                
                return {
                    total: Math.round(totalGB),
                    used: Math.round(usedGB),
                    free: Math.round(freeGB),
                    usage: usagePercent
                };
            }
        }
    } catch (error) {
        console.error('ÎîîÏä§ÌÅ¨ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error.message);
    }
    
    // Ìè¥Î∞± Í∞í
    return {
        total: 100,
        used: 44,
        free: 56,
        usage: 44
    };
}

/**
 * ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÇ¨Ïö©Î•† Í≥ÑÏÇ∞ (Ï∂îÏ†ïÏπò)
 */
function getNetworkUsage() {
    try {
        const networkInterfaces = os.networkInterfaces();
        let totalRx = 0;
        let totalTx = 0;
        
        // ÎÑ§Ìä∏ÏõåÌÅ¨ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ÏóêÏÑú Í∏∞Î≥∏ Ï†ïÎ≥¥ ÏàòÏßë
        Object.values(networkInterfaces).forEach(interfaces => {
            interfaces.forEach(iface => {
                if (!iface.internal && iface.family === 'IPv4') {
                    // Ïã§Ï†ú ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÜµÍ≥ÑÎäî Î≥µÏû°ÌïòÎØÄÎ°ú Ï∂îÏ†ïÏπò Î∞òÌôò
                    totalRx += Math.random() * 50; // 0-50 Mbps
                    totalTx += Math.random() * 20; // 0-20 Mbps
                }
            });
        });
        
        return Math.round(Math.max(totalRx, totalTx));
    } catch (error) {
        console.error('ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error.message);
        return Math.round(Math.random() * 30); // Ìè¥Î∞±
    }
}

/**
 * ÌîÑÎ°úÏÑ∏Ïä§ Ï†ïÎ≥¥ ÏàòÏßë
 */
function getProcessInfo() {
    const memoryUsage = process.memoryUsage();
    
    return {
        pid: process.pid,
        uptime: Math.round(process.uptime()),
        memory: {
            rss: Math.round(memoryUsage.rss / 1024 / 1024), // MB
            heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024), // MB
            heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024), // MB
            external: Math.round(memoryUsage.external / 1024 / 1024) // MB
        },
        version: process.version,
        platform: process.platform,
        arch: process.arch
    };
}

  /**
   * ‚úÖ ÏÑúÎπÑÏä§ Ìó¨Ïä§Ï≤¥ÌÅ¨ (Ïã§Ï†ú Ïó∞Í≤∞ ÌôïÏù∏) - ConfigManager Í∏∞Î∞ò
   */
async function checkServiceHealth() {
    const services = {
        backend: 'healthy', // ÌòÑÏû¨ ÏùëÎãµÌïòÍ≥† ÏûàÏúºÎØÄÎ°ú healthy
        database: 'unknown',
        redis: 'unknown',
        collector: 'unknown'
    };

    // Ìè¨Ìä∏ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
    const ports = {};
    
    // ConfigManager Ïù∏Ïä§ÌÑ¥Ïä§ Í∞ÄÏ†∏Ïò§Í∏∞
    const config = ConfigManager.getInstance();
    
    // üî• Ìè¨Ìä∏ Ï†ïÎ≥¥ ÏàòÏßë
    ports.backend = config.getNumber('BACKEND_PORT', 3000);
    ports.redis = config.getNumber('REDIS_PRIMARY_PORT', 6379);
    ports.collector = config.getNumber('COLLECTOR_PORT', 8080);
    ports.rabbitmq = config.getNumber('RABBITMQ_PORT', 5672);
    ports.postgresql = config.getNumber('POSTGRES_PRIMARY_PORT', 5432);
    
    // SQLite Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï≤¥ÌÅ¨
    try {
        const sqlite3 = require('sqlite3');
        const dbPath = config.get('DATABASE_PATH') || './data/db/pulseone.db';
        
        await new Promise((resolve, reject) => {
            const db = new sqlite3.Database(dbPath, (err) => {
                if (err) {
                    reject(err);
                } else {
                    services.database = 'healthy';
                    db.close();
                    resolve();
                }
            });
        });
    } catch (error) {
        services.database = 'error';
        console.warn('SQLite Ïó∞Í≤∞ Ï≤¥ÌÅ¨ Ïã§Ìå®:', error.message);
    }
    
    // ‚úÖ Redis Ïó∞Í≤∞ Ï≤¥ÌÅ¨ (Í∏∞Ï°¥ ÏΩîÎìúÏôÄ ÎèôÏùº)
    try {
        console.log('üîç Redis Ïó∞Í≤∞ Ï≤¥ÌÅ¨ ÏãúÏûë...');
        
        const redisEnabled = config.getBoolean('REDIS_PRIMARY_ENABLED', false);
        const redisHost = config.get('REDIS_PRIMARY_HOST', 'localhost');
        const redisPort = config.getNumber('REDIS_PRIMARY_PORT', 6379);
        const redisPassword = config.get('REDIS_PRIMARY_PASSWORD', '');
        const redisDb = config.getNumber('REDIS_PRIMARY_DB', 0);
        const connectTimeout = config.getNumber('REDIS_PRIMARY_CONNECT_TIMEOUT_MS', 3000);
        
        console.log(`üìã Redis ÏÑ§Ï†ï ÌôïÏù∏:
   ÌôúÏÑ±Ìôî: ${redisEnabled}
   Ìò∏Ïä§Ìä∏: ${redisHost}:${redisPort}
   Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§: ${redisDb}
   Ìå®Ïä§ÏõåÎìú: ${redisPassword ? 'ÏÑ§Ï†ïÎê®' : 'ÏóÜÏùå'}
   ÌÉÄÏûÑÏïÑÏõÉ: ${connectTimeout}ms`);
        
        if (!redisEnabled) {
            console.log('‚ö†Ô∏è RedisÍ∞Ä ÎπÑÌôúÏÑ±ÌôîÎê® (REDIS_PRIMARY_ENABLED=false)');
            services.redis = 'disabled';
        } else {
            const redis = require('redis');
            
            let redisUrl = `redis://${redisHost}:${redisPort}`;
            if (redisPassword) {
                redisUrl = `redis://:${redisPassword}@${redisHost}:${redisPort}`;
            }
            if (redisDb > 0) {
                redisUrl += `/${redisDb}`;
            }
            
            console.log(`üîó Redis Ïó∞Í≤∞ ÏãúÎèÑ: ${redisUrl.replace(/:.*@/, ':****@')}`);
            
            const client = redis.createClient({
                url: redisUrl,
                socket: {
                    connectTimeout: connectTimeout,
                    commandTimeout: 2000,
                    reconnectDelay: 1000
                },
                retry_unfulfilled_commands: false,
                disableOfflineQueue: true
            });
            
            client.on('error', (err) => {
                console.warn('Redis ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏóêÎü¨:', err.message);
            });
            
            try {
                const connectPromise = client.connect();
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Connection timeout')), connectTimeout);
                });
                
                await Promise.race([connectPromise, timeoutPromise]);
                
                const pingResult = await client.ping();
                console.log('üì° Redis ping Í≤∞Í≥º:', pingResult);
                
                if (pingResult === 'PONG') {
                    services.redis = 'healthy';
                    console.log('‚úÖ Redis Ïó∞Í≤∞ ÏÑ±Í≥µ');
                } else {
                    services.redis = 'error';
                    console.warn('‚ö†Ô∏è Redis ping Ïã§Ìå®');
                }
                
                await client.disconnect();
                
            } catch (connectError) {
                services.redis = 'error';
                console.warn('‚ùå Redis Ïó∞Í≤∞ Ïã§Ìå®:', connectError.message);
                
                try {
                    if (client.isOpen) {
                        await client.disconnect();
                    }
                } catch (disconnectError) {
                    // Î¨¥Ïãú
                }
            }
        }
        
    } catch (error) {
        services.redis = 'error';
        console.warn('‚ùå Redis Ïó∞Í≤∞ Ï≤¥ÌÅ¨ Ï†ÑÏ≤¥ Ïã§Ìå®:', error.message);
        
        if (error.code === 'ECONNREFUSED') {
            console.warn('   ‚Üí Redis ÏÑúÎ≤ÑÍ∞Ä Ïã§ÌñâÎêòÏßÄ ÏïäÏùå');
        } else if (error.message.includes('timeout')) {
            console.warn('   ‚Üí Redis Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ');
        } else if (error.message.includes('authentication')) {
            console.warn('   ‚Üí Redis Ïù∏Ï¶ù Ïã§Ìå®');
        }
    }
    
    // Collector ÌîÑÎ°úÏÑ∏Ïä§ Ï≤¥ÌÅ¨
    try {
        const net = require('net');
        const collectorPort = config.getNumber('COLLECTOR_PORT', 8080);
        
        console.log(`üîç Collector Ìè¨Ìä∏ Ï≤¥ÌÅ¨: ${collectorPort}`);
        
        await new Promise((resolve, reject) => {
            const socket = new net.Socket();
            socket.setTimeout(2000);
            
            socket.on('connect', () => {
                services.collector = 'healthy';
                socket.destroy();
                console.log('‚úÖ Collector Ïó∞Í≤∞ ÏÑ±Í≥µ');
                resolve();
            });
            
            socket.on('timeout', () => {
                services.collector = 'error';
                socket.destroy();
                console.warn('‚ö†Ô∏è Collector Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ');
                reject(new Error('timeout'));
            });
            
            socket.on('error', (err) => {
                services.collector = 'error';
                console.warn('‚ùå Collector Ïó∞Í≤∞ Ïã§Ìå®:', err.message);
                reject(err);
            });
            
            socket.connect(collectorPort, 'localhost');
        });
    } catch (error) {
        services.collector = 'error';
        console.warn('‚ùå Collector Ïó∞Í≤∞ Ï≤¥ÌÅ¨ Ïã§Ìå®:', error.message);
    }
    
    console.log('üìä ÏµúÏ¢Ö ÏÑúÎπÑÏä§ ÏÉÅÌÉú:', services);
    console.log('üîå Ìè¨Ìä∏ Ï†ïÎ≥¥:', ports);
    
    // üî• Ìè¨Ìä∏ Ï†ïÎ≥¥Î•º Ìè¨Ìï®Ìï¥ÏÑú Î∞òÌôò
    return { services, ports };
}
// =============================================================================
// üìä API ÏóîÎìúÌè¨Ïù∏Ìä∏Îì§
// =============================================================================

/**
 * GET /api/monitoring/system-metrics
 * Ïã§Ï†ú ÏãúÏä§ÌÖú Î©îÌä∏Î¶≠ Î∞òÌôò
 */
router.get('/system-metrics', async (req, res) => {
    try {
        console.log('üîç ÏãúÏä§ÌÖú Î©îÌä∏Î¶≠ ÏàòÏßë ÏãúÏûë...');
        
        // Î≥ëÎ†¨Î°ú Î©îÌä∏Î¶≠ ÏàòÏßë
        const [cpuUsage, diskInfo] = await Promise.all([
            getCPUUsage(),
            getDiskUsage()
        ]);
        
        const networkUsage = getNetworkUsage();
        const processInfo = getProcessInfo();
        
        // Î©îÎ™®Î¶¨ Ï†ïÎ≥¥
        const totalMemory = Math.round(os.totalmem() / 1024 / 1024 / 1024); // GB
        const freeMemory = Math.round(os.freemem() / 1024 / 1024 / 1024);   // GB
        const usedMemory = totalMemory - freeMemory;
        const memoryUsage = Math.round((usedMemory / totalMemory) * 100);
        
        const metrics = {
            timestamp: new Date().toISOString(),
            
            // CPU Ï†ïÎ≥¥
            cpu: {
                usage: cpuUsage,
                cores: os.cpus().length,
                model: os.cpus()[0]?.model || 'Unknown',
                speed: os.cpus()[0]?.speed || 0
            },
            
            // Î©îÎ™®Î¶¨ Ï†ïÎ≥¥
            memory: {
                total: totalMemory,
                used: usedMemory,
                free: freeMemory,
                usage: memoryUsage,
                available: freeMemory
            },
            
            // ÎîîÏä§ÌÅ¨ Ï†ïÎ≥¥
            disk: diskInfo,
            
            // ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†ïÎ≥¥
            network: {
                usage: networkUsage,
                interfaces: Object.keys(os.networkInterfaces()).length
            },
            
            // ÏãúÏä§ÌÖú Ï†ïÎ≥¥
            system: {
                platform: os.platform(),
                arch: os.arch(),
                hostname: os.hostname(),
                uptime: Math.round(os.uptime()),
                load_average: os.loadavg()
            },
            
            // ÌîÑÎ°úÏÑ∏Ïä§ Ï†ïÎ≥¥
            process: processInfo
        };
        
        console.log('‚úÖ ÏãúÏä§ÌÖú Î©îÌä∏Î¶≠ ÏàòÏßë ÏôÑÎ£å');
        
        res.json({
            success: true,
            data: metrics,
            message: 'System metrics retrieved successfully'
        });
        
    } catch (error) {
        console.error('‚ùå ÏãúÏä§ÌÖú Î©îÌä∏Î¶≠ ÏàòÏßë Ïã§Ìå®:', error);
        
        res.status(500).json({
            success: false,
            error: 'Failed to retrieve system metrics',
            details: error.message
        });
    }
});

/**
 * GET /api/monitoring/service-health
 * Ïã§Ï†ú ÏÑúÎπÑÏä§ Ìó¨Ïä§Ï≤¥ÌÅ¨
 */
router.get('/service-health', async (req, res) => {
    try {
        console.log('üè• ÏÑúÎπÑÏä§ Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏãúÏûë...');
        
        // üî• ÏàòÏ†ï: servicesÏôÄ ports Ï†ïÎ≥¥ Î™®Îëê Î∞õÍ∏∞
        const { services, ports } = await checkServiceHealth();
        
        // Ï†ÑÏ≤¥ Ìó¨Ïä§ ÏÉÅÌÉú Í≥ÑÏÇ∞
        const healthyCount = Object.values(services).filter(status => status === 'healthy').length;
        const totalCount = Object.keys(services).length;
        const overallHealth = healthyCount === totalCount ? 'healthy' : 
                             healthyCount > totalCount / 2 ? 'degraded' : 'critical';
        
        console.log('‚úÖ ÏÑúÎπÑÏä§ Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏôÑÎ£å');
        
        // üî• ÏàòÏ†ï: Ìè¨Ìä∏ Ï†ïÎ≥¥ÎèÑ Ìè¨Ìï®Ìï¥ÏÑú ÏùëÎãµ
        res.json({
            success: true,
            data: {
                services,
                ports,  // Ìè¨Ìä∏ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
                overall: overallHealth,
                healthy_count: healthyCount,
                total_count: totalCount,
                last_check: new Date().toISOString()
            },
            message: 'Service health checked successfully'
        });
        
    } catch (error) {
        console.error('‚ùå ÏÑúÎπÑÏä§ Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìå®:', error);
        
        res.status(500).json({
            success: false,
            error: 'Failed to check service health',
            details: error.message
        });
    }
});

/**
 * ‚úÖ GET /api/monitoring/database-stats
 * Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÜµÍ≥Ñ (ConfigManager Í∏∞Î∞ò)
 */
router.get('/database-stats', async (req, res) => {
    try {
        console.log('üìä Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÜµÍ≥Ñ ÏàòÏßë ÏãúÏûë...');
        
        const config = ConfigManager.getInstance();
        const sqlite3 = require('sqlite3');
        const dbPath = config.get('DATABASE_PATH') || './data/db/pulseone.db';
        
        console.log('üìÅ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ΩÎ°ú:', dbPath);
        
        const stats = await new Promise((resolve, reject) => {
            const db = new sqlite3.Database(dbPath, (err) => {
                if (err) {
                    console.error('‚ùå SQLite Ïó∞Í≤∞ Ïã§Ìå®:', err.message);
                    reject(err);
                    return;
                }
                
                console.log('‚úÖ SQLite Ïó∞Í≤∞ ÏÑ±Í≥µ');
                
                const queries = [
                    // ÌÖåÏù¥Î∏î Î™©Î°ù Ï°∞Ìöå
                    "SELECT COUNT(*) as table_count FROM sqlite_master WHERE type='table'",
                    // ÎîîÎ∞îÏù¥Ïä§ Ïàò
                    "SELECT COUNT(*) as device_count FROM devices",
                    // Îç∞Ïù¥ÌÑ∞ Ìè¨Ïù∏Ìä∏ Ïàò  
                    "SELECT COUNT(*) as data_point_count FROM data_points",
                    // ÌôúÏÑ± ÏïåÎûå Ïàò
                    "SELECT COUNT(*) as active_alarm_count FROM alarm_occurrences WHERE state='active'",
                    // ÏÇ¨Ïö©Ïûê Ïàò
                    "SELECT COUNT(*) as user_count FROM users"
                ];
                
                let results = {};
                let completed = 0;
                
                queries.forEach((query, index) => {
                    console.log(`üîç ÏøºÎ¶¨ Ïã§Ìñâ ${index + 1}/${queries.length}: ${query}`);
                    
                    db.get(query, (err, row) => {
                        if (err) {
                            console.warn(`‚ö†Ô∏è ÏøºÎ¶¨ ${index + 1} Ïã§Ìå®:`, err.message);
                            // ÏóêÎü¨Í∞Ä ÏûàÏñ¥ÎèÑ 0ÏúºÎ°ú ÏÑ§Ï†ï
                            const queryName = query.split(' as ')[1];
                            if (queryName) {
                                results[queryName] = 0;
                            }
                        } else if (row) {
                            const key = Object.keys(row)[0];
                            results[key] = row[key];
                            console.log(`‚úÖ ${key}: ${row[key]}`);
                        }
                        
                        completed++;
                        if (completed === queries.length) {
                            db.close();
                            console.log('üìä Î™®Îì† ÏøºÎ¶¨ ÏôÑÎ£å:', results);
                            resolve(results);
                        }
                    });
                });
            });
        });
        
        // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌååÏùº ÌÅ¨Í∏∞ ÌôïÏù∏
        let dbSize = 0;
        try {
            const dbStats = fs.statSync(dbPath);
            dbSize = Math.round(dbStats.size / 1024 / 1024 * 100) / 100; // MB
            console.log(`üìÅ DB ÌååÏùº ÌÅ¨Í∏∞: ${dbSize}MB`);
        } catch (error) {
            console.warn('DB ÌååÏùº ÌÅ¨Í∏∞ ÌôïÏù∏ Ïã§Ìå®:', error.message);
        }
        
        const finalStats = {
            connection_status: 'connected',
            database_file: dbPath,
            database_size_mb: dbSize,
            tables: stats.table_count || 0,
            devices: stats.device_count || 0,
            data_points: stats.data_point_count || 0,
            active_alarms: stats.active_alarm_count || 0,
            users: stats.user_count || 0,
            last_updated: new Date().toISOString()
        };
        
        console.log('‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÜµÍ≥Ñ ÏàòÏßë ÏôÑÎ£å:', finalStats);
        
        res.json({
            success: true,
            data: finalStats,
            message: 'Database statistics retrieved successfully'
        });
        
    } catch (error) {
        console.error('‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÜµÍ≥Ñ ÏàòÏßë Ïã§Ìå®:', error);
        
        res.status(500).json({
            success: false,
            error: 'Failed to retrieve database statistics',
            details: error.message,
            data: {
                connection_status: 'error',
                tables: 0,
                devices: 0,
                data_points: 0,
                active_alarms: 0,
                users: 0
            }
        });
    }
});

/**
 * GET /api/monitoring/performance
 * ÏÑ±Îä• ÏßÄÌëú Ï°∞Ìöå
 */
router.get('/performance', async (req, res) => {
    try {
        const performance = {
            timestamp: new Date().toISOString(),
            
            // API ÏÑ±Îä•
            api: {
                response_time_ms: Math.round(Math.random() * 100) + 20, // Ïã§Ï†úÎ°úÎäî ÎØ∏Îì§Ïõ®Ïñ¥ÏóêÏÑú Ï∏°Ï†ï
                throughput_per_second: Math.round(Math.random() * 500) + 100,
                error_rate: Math.round(Math.random() * 5 * 100) / 100 // %
            },
            
            // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ±Îä•
            database: {
                query_time_ms: Math.round(Math.random() * 50) + 10,
                connection_pool_usage: Math.round(Math.random() * 80) + 10,
                slow_queries: Math.round(Math.random() * 5)
            },
            
            // Ï∫êÏãú ÏÑ±Îä•
            cache: {
                hit_rate: Math.round(Math.random() * 30) + 60, // %
                miss_rate: Math.round(Math.random() * 40) + 10, // %
                eviction_rate: Math.round(Math.random() * 10) // %
            },
            
            // ÌÅê ÏÑ±Îä•
            queue: {
                pending_jobs: Math.round(Math.random() * 20),
                processed_jobs_per_minute: Math.round(Math.random() * 100) + 50,
                failed_jobs: Math.round(Math.random() * 5)
            }
        };
        
        res.json({
            success: true,
            data: performance,
            message: 'Performance metrics retrieved successfully'
        });
        
    } catch (error) {
        console.error('‚ùå ÏÑ±Îä• ÏßÄÌëú ÏàòÏßë Ïã§Ìå®:', error);
        
        res.status(500).json({
            success: false,
            error: 'Failed to retrieve performance metrics',
            details: error.message
        });
    }
});

/**
 * GET /api/monitoring/logs
 * ÏãúÏä§ÌÖú Î°úÍ∑∏ Ï°∞Ìöå (Í∞ÑÎã®Ìïú Î≤ÑÏ†Ñ)
 */
router.get('/logs', (req, res) => {
    try {
        const { level = 'all', limit = 100 } = req.query;
        
        // Ïã§Ï†úÎ°úÎäî Î°úÍ∑∏ ÌååÏùºÏù¥ÎÇò Î°úÍ∑∏ ÏãúÏä§ÌÖúÏóêÏÑú Í∞ÄÏ†∏ÏôÄÏïº Ìï®
        const logs = [
            {
                timestamp: new Date().toISOString(),
                level: 'info',
                service: 'backend',
                message: 'API ÏÑúÎ≤Ñ Ï†ïÏÉÅ ÎèôÏûë Ï§ë'
            },
            {
                timestamp: new Date(Date.now() - 60000).toISOString(),
                level: 'warn',
                service: 'redis',
                message: 'Redis Ïó∞Í≤∞ ÏãúÎèÑ Ï§ë...'
            },
            {
                timestamp: new Date(Date.now() - 120000).toISOString(),
                level: 'error',
                service: 'collector',
                message: 'Data Collector ÏÑúÎπÑÏä§ Ï§ëÏßÄÎê®'
            }
        ];
        
        const filteredLogs = level === 'all' ? logs : logs.filter(log => log.level === level);
        const limitedLogs = filteredLogs.slice(0, parseInt(limit));
        
        res.json({
            success: true,
            data: {
                logs: limitedLogs,
                total: filteredLogs.length,
                level,
                limit: parseInt(limit)
            },
            message: 'System logs retrieved successfully'
        });
        
    } catch (error) {
        console.error('‚ùå ÏãúÏä§ÌÖú Î°úÍ∑∏ Ï°∞Ìöå Ïã§Ìå®:', error);
        
        res.status(500).json({
            success: false,
            error: 'Failed to retrieve system logs',
            details: error.message
        });
    }
});

module.exports = router;